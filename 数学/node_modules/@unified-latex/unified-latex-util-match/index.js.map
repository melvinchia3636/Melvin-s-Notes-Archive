{
  "version": 3,
  "sources": ["../libs/match.ts", "../index.ts"],
  "sourcesContent": ["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, MacroInfo, MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createMacroMatcher(\n    macros: Ast.Macro[] | string[] | Record<string, unknown>\n) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const macrosHash = Array.isArray(macros)\n        ? macros.length > 0\n            ? typeof macros[0] === \"string\"\n                ? Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro !== \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          return [macro, {}] as [string, MacroInfo];\n                      })\n                  )\n                : Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro === \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          if (macro.escapeToken != null) {\n                              return [\n                                  macro.content,\n                                  { escapeToken: macro.escapeToken },\n                              ] as [string, MacroInfo];\n                          }\n                          return [macro.content, {}] as [string, MacroInfo];\n                      })\n                  )\n            : {}\n        : macros;\n\n    return function matchAgainstMacros(node: any | Ast.Macro) {\n        if (node == null || node.type !== \"macro\") {\n            return false;\n        }\n        // At this point we have a macro type\n        const spec = macrosHash[node.content];\n        if (!spec) {\n            return false;\n        }\n\n        if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n            return (\n                (spec as MacroInfoRecord).escapeToken == null ||\n                (spec as MacroInfoRecord).escapeToken === node.escapeToken\n            );\n        }\n        return true;\n    } as Ast.TypeGuard<Ast.Macro>;\n}\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createEnvironmentMatcher(macros: string[] | Record<string, unknown>) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const environmentsHash = Array.isArray(macros)\n        ? Object.fromEntries(\n              macros.map((str) => {\n                  return [str, {}] as [string, EnvInfo];\n              })\n          )\n        : macros;\n\n    return function matchAgainstEnvironments(node: any | Ast.Environment) {\n        if (!match.anyEnvironment(node)) {\n            return false;\n        }\n        // At this point we have an environment type\n        const envName = printRaw(node.env);\n        const spec = environmentsHash[envName];\n        if (!spec) {\n            return false;\n        }\n\n        return true;\n    } as Ast.TypeGuard<Ast.Environment>;\n}\n\n/**\n * Functions to match different types of nodes.\n */\nexport const match = {\n    macro(node: any, macroName?: string): node is Ast.Macro {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"macro\" &&\n            (macroName == null || node.content === macroName)\n        );\n    },\n    anyMacro(node: any): node is Ast.Macro {\n        return match.macro(node);\n    },\n    environment(node: any, envName?: string): node is Ast.Environment {\n        if (node == null) {\n            return false;\n        }\n        return (\n            (node.type === \"environment\" || node.type === \"mathenv\") &&\n            (envName == null || printRaw(node.env) === envName)\n        );\n    },\n    anyEnvironment(node: any): node is Ast.Environment {\n        return match.environment(node);\n    },\n    comment(node: any): node is Ast.Comment {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"comment\";\n    },\n    parbreak(node: any): node is Ast.Parbreak {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"parbreak\";\n    },\n    whitespace(node: any): node is Ast.Whitespace {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"whitespace\";\n    },\n    /**\n     * Matches whitespace or a comment with leading whitespace.\n     */\n    whitespaceLike(\n        node: any\n    ): node is Ast.Whitespace | (Ast.Comment & { leadingWhitespace: true }) {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"whitespace\" ||\n            (node.type === \"whitespace\" && node.leadingWhitespace === true)\n        );\n    },\n    string(node: any, value?: string): node is Ast.String {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"string\" && (value == null || node.content === value)\n        );\n    },\n    anyString(node: any): node is Ast.String {\n        return match.string(node);\n    },\n    group(node: any): node is Ast.Group {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"group\";\n    },\n    argument(node: any): node is Ast.Argument {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"argument\";\n    },\n    blankArgument(node: any): boolean {\n        if (!match.argument(node)) {\n            return false;\n        }\n        return (\n            node.openMark === \"\" &&\n            node.closeMark === \"\" &&\n            node.content.length === 0\n        );\n    },\n    math(node: any): node is Ast.DisplayMath | Ast.InlineMath {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"displaymath\" || node.type === \"inlinemath\";\n    },\n    createMacroMatcher,\n    createEnvironmentMatcher,\n};\n", "import { match } from \"./libs/match\";\n\nexport { match };\n\nexport const {\n    anyEnvironment,\n    anyMacro,\n    anyString,\n    argument,\n    blankArgument,\n    comment,\n    environment,\n    group,\n    macro,\n    math,\n    parbreak,\n    string,\n    whitespace,\n} = match;\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.\n */\n"],
  "mappings": "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",
  "names": []
}
