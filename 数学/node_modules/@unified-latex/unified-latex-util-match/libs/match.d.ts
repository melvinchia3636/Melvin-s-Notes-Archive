import * as Ast from "@unified-latex/unified-latex-types";
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
declare function createMacroMatcher(macros: Ast.Macro[] | string[] | Record<string, unknown>): Ast.TypeGuard<Ast.Macro>;
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
declare function createEnvironmentMatcher(macros: string[] | Record<string, unknown>): Ast.TypeGuard<Ast.Environment>;
/**
 * Functions to match different types of nodes.
 */
export declare const match: {
    macro(node: any, macroName?: string | undefined): node is Ast.Macro;
    anyMacro(node: any): node is Ast.Macro;
    environment(node: any, envName?: string | undefined): node is Ast.Environment;
    anyEnvironment(node: any): node is Ast.Environment;
    comment(node: any): node is Ast.Comment;
    parbreak(node: any): node is Ast.Parbreak;
    whitespace(node: any): node is Ast.Whitespace;
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node: any): node is Ast.Whitespace | (Ast.Comment & {
        leadingWhitespace: true;
    });
    string(node: any, value?: string | undefined): node is Ast.String;
    anyString(node: any): node is Ast.String;
    group(node: any): node is Ast.Group;
    argument(node: any): node is Ast.Argument;
    blankArgument(node: any): boolean;
    math(node: any): node is Ast.InlineMath | Ast.DisplayMath;
    createMacroMatcher: typeof createMacroMatcher;
    createEnvironmentMatcher: typeof createEnvironmentMatcher;
};
export {};
//# sourceMappingURL=match.d.ts.map