var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_visit_exports = {};
__export(unified_latex_util_visit_exports, {
  CONTINUE: () => CONTINUE,
  EXIT: () => EXIT,
  SKIP: () => SKIP,
  visit: () => visit
});
module.exports = __toCommonJS(unified_latex_util_visit_exports);

// libs/list-math-children.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
function listMathChildren(node) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node)) {
    return NULL_RETURN;
  }
  if (import_unified_latex_util_match.match.math(node)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (import_unified_latex_util_match.match.macro(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (import_unified_latex_util_match.match.environment(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}

// libs/visit.ts
var CONTINUE = Symbol("continue");
var SKIP = Symbol("skip");
var EXIT = Symbol("exit");
var DEFAULT_CONTEXT = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit(tree, visitor, options) {
  const {
    startingContext = DEFAULT_CONTEXT,
    test = () => true,
    includeArrays = false
  } = options || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: __spreadValues({}, startingContext)
  });
  function walk(node, { key, index, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node, { key, index, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult(enter(node, {
      key,
      index,
      parents,
      context,
      containingArray
    })) : [CONTINUE];
    if (result[0] === EXIT) {
      return result;
    }
    if (result[0] === SKIP) {
      return leave && nodePassesTest ? toResult(leave(node, {
        key,
        index,
        parents,
        context,
        containingArray
      })) : result;
    }
    if (Array.isArray(node)) {
      for (let index2 = 0; index2 > -1 && index2 < node.length; index2++) {
        const item = node[index2];
        const result2 = walk(item, {
          key,
          index: index2,
          parents,
          context,
          containingArray: node
        });
        if (result2[0] === EXIT) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index2 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
        default:
          break;
      }
      const mathModeProps = listMathChildren(node);
      for (const key2 of childProps) {
        const value = node[key2];
        const grandparents = [node].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = __spreadValues({}, context);
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: void 0,
          parents: grandparents,
          context: newContext,
          containingArray: void 0
        });
        if (result2[0] === EXIT) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult(leave(node, {
      key,
      index,
      parents,
      context,
      containingArray
    })) : result;
  }
}
function toResult(value) {
  if (value == null) {
    return [CONTINUE];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
//# sourceMappingURL=index.cjs.map
