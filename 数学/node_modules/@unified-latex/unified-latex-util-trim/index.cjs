var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_trim_exports = {};
__export(unified_latex_util_trim_exports, {
  hasWhitespaceEquivalent: () => hasWhitespaceEquivalent,
  trim: () => trim,
  trimEnd: () => trimEnd,
  trimStart: () => trimStart,
  unifiedLatexTrimEnvironmentContents: () => unifiedLatexTrimEnvironmentContents,
  unifiedLatexTrimRoot: () => unifiedLatexTrimRoot
});
module.exports = __toCommonJS(unified_latex_util_trim_exports);

// libs/trim.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
function trim(nodes) {
  if (!Array.isArray(nodes)) {
    console.warn("Trying to trim a non-array ast", nodes);
    return nodes;
  }
  const { trimmedStart } = trimStart(nodes);
  const { trimmedEnd } = trimEnd(nodes);
  return { trimmedStart, trimmedEnd };
}
function trimStart(nodes) {
  const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(0, start);
  for (const leadingToken of nodes) {
    if (!import_unified_latex_util_match.match.comment(leadingToken)) {
      break;
    }
    if (leadingToken.leadingWhitespace || leadingToken.sameline) {
      leadingToken.leadingWhitespace = false;
      delete leadingToken.position;
    }
    if (start > 0 && leadingToken.sameline) {
      leadingToken.sameline = false;
      delete leadingToken.position;
    }
  }
  return { trimmedStart: start };
}
function trimEnd(nodes) {
  const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(nodes.length - end, end);
  for (let i = nodes.length - 1; i >= 0; i--) {
    const trailingToken = nodes[i];
    if (!import_unified_latex_util_match.match.comment(trailingToken)) {
      break;
    }
    delete trailingToken.suffixParbreak;
    if (import_unified_latex_util_match.match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
      trailingToken.leadingWhitespace = false;
      delete trailingToken.position;
    }
  }
  return { trimmedEnd: end };
}
function amountOfLeadingAndTrailingWhitespace(ast) {
  let start = 0;
  let end = 0;
  for (const node of ast) {
    if (import_unified_latex_util_match.match.whitespace(node) || import_unified_latex_util_match.match.parbreak(node)) {
      start++;
    } else {
      break;
    }
  }
  if (start === ast.length) {
    return { start, end: 0 };
  }
  for (let i = ast.length - 1; i >= 0; i--) {
    const node = ast[i];
    if (import_unified_latex_util_match.match.whitespace(node) || import_unified_latex_util_match.match.parbreak(node)) {
      end++;
    } else {
      break;
    }
  }
  return { start, end };
}

// libs/unified-latex-trim-environment-contents.ts
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_visit = require("@unified-latex/unified-latex-util-visit");
var unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
  return (tree) => {
    (0, import_unified_latex_util_visit.visit)(tree, (node) => {
      if (!(import_unified_latex_util_match2.match.math(node) || import_unified_latex_util_match2.match.anyEnvironment(node))) {
        return;
      }
      let firstNode = node.content[0];
      if (import_unified_latex_util_match2.match.comment(firstNode) && firstNode.sameline) {
        firstNode.suffixParbreak = false;
        trimEnd(node.content);
        const { trimmedStart } = trimStart(node.content.slice(1));
        node.content.splice(1, trimmedStart);
      } else {
        trim(node.content);
      }
    });
  };
};

// libs/unified-latex-trim-root.ts
var unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
  return (tree) => {
    trim(tree.content);
  };
};

// libs/has-whitespace-equivalent.ts
var import_unified_latex_util_match3 = require("@unified-latex/unified-latex-util-match");
function hasWhitespaceEquivalent(nodes) {
  let start = false;
  let end = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (import_unified_latex_util_match3.match.comment(node)) {
      if (node.leadingWhitespace) {
        start = true;
        break;
      }
      continue;
    }
    if (import_unified_latex_util_match3.match.whitespace(node)) {
      start = true;
    }
    break;
  }
  for (let j = nodes.length - 1; j >= 0; j--) {
    const node = nodes[j];
    if (import_unified_latex_util_match3.match.comment(node)) {
      if (node.leadingWhitespace) {
        end = true;
        break;
      }
      continue;
    }
    if (import_unified_latex_util_match3.match.whitespace(node)) {
      end = true;
    }
    break;
  }
  return { start, end };
}
//# sourceMappingURL=index.cjs.map
