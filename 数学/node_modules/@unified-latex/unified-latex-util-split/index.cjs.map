{
  "version": 3,
  "sources": ["../index.ts", "../libs/split-on-macro.ts", "../libs/split-on-condition.ts", "../libs/unsplit-on-macro.ts", "../libs/array-join.ts"],
  "sourcesContent": ["export * from \"./libs/split-on-macro\";\nexport * from \"./libs/split-on-condition\";\nexport * from \"./libs/unsplit-on-macro\";\nexport * from \"./libs/array-join\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to manipulate `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you want break apart or join an array of nodes based on a condition. For example,\n * this is used to split on `&` characters in the `align` environment.\n */", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { splitOnCondition } from \"./split-on-condition\";\n\n/**\n * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`\n * is returned. The original array is reconstructed as\n * `segments[0] + macros[0] + segments[1] + ...`.\n *\n * @param {[object]} ast\n * @param {(string|[string])} macroName\n * @returns {{segments: [object], macros: [object]}}\n */\nexport function splitOnMacro(\n    ast: Ast.Node[],\n    macroName: string | string[]\n): { segments: Ast.Node[][]; macros: Ast.Macro[] } {\n    if (typeof macroName === \"string\") {\n        macroName = [macroName];\n    }\n    if (!Array.isArray(macroName)) {\n        throw new Error(\"Type coercion failed\");\n    }\n    const isSeparator = match.createMacroMatcher(macroName);\n    const { segments, separators } = splitOnCondition(ast, isSeparator);\n    return { segments, macros: separators as Ast.Macro[] };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Split a list of nodes based on whether `splitFunc` returns `true`.\n * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then\n * there will be at most two segments returned.\n */\nexport function splitOnCondition(\n    nodes: Ast.Node[],\n    splitFunc: (node: Ast.Node) => boolean = () => false,\n    options?: { onlySplitOnFirstOccurrence?: boolean }\n): { segments: Ast.Node[][]; separators: Ast.Node[] } {\n    if (!Array.isArray(nodes)) {\n        throw new Error(`Can only split an Array, not ${nodes}`);\n    }\n\n    const { onlySplitOnFirstOccurrence = false } = options || {};\n\n    const splitIndices: number[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n        if (splitFunc(nodes[i])) {\n            splitIndices.push(i);\n            if (onlySplitOnFirstOccurrence) {\n                break;\n            }\n        }\n    }\n\n    // Short circuit if there is no splitting to be done\n    if (splitIndices.length === 0) {\n        return { segments: [nodes], separators: [] };\n    }\n\n    let separators = splitIndices.map((i) => nodes[i]);\n    let segments = splitIndices.map((splitEnd, i) => {\n        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;\n        return nodes.slice(splitStart, splitEnd);\n    });\n    segments.push(\n        nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)\n    );\n\n    return { segments, separators };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Does the reverse of `splitOnMacro`\n */\nexport function unsplitOnMacro({\n    segments,\n    macros,\n}: {\n    segments: Ast.Node[][];\n    macros: Ast.Node[] | Ast.Node[][];\n}) {\n    if (segments.length === 0) {\n        console.warn(\"Trying to join zero segments\");\n        return [];\n    }\n    if (segments.length !== macros.length + 1) {\n        console.warn(\n            \"Mismatch between lengths of macros and segments when trying to unsplit\"\n        );\n    }\n\n    let ret = segments[0];\n    for (let i = 0; i < macros.length; i++) {\n        // Even though the type of macros[i] is node and not array,\n        // Array.concat still works\n        ret = ret.concat(macros[i]).concat(segments[i + 1]);\n    }\n\n    return ret;\n}\n", "/**\n * Joins an array of arrays with the item `sep`\n */\nexport function arrayJoin<T>(array: T[][], sep: T | T[]): T[] {\n    return array.flatMap((item, i) => {\n        if (i === 0) {\n            return item;\n        }\n        if (Array.isArray(sep)) {\n            return [...sep, ...item];\n        } else {\n            return [sep, ...item];\n        }\n    });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,sCAAsB;;;ACMf,0BACH,OACA,YAAyC,MAAM,OAC/C,SACkD;AAClD,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,UAAM,IAAI,MAAM,gCAAgC,OAAO;AAAA,EAC3D;AAEA,QAAM,EAAE,6BAA6B,UAAU,WAAW,CAAC;AAE3D,QAAM,eAAyB,CAAC;AAChC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,QAAI,UAAU,MAAM,EAAE,GAAG;AACrB,mBAAa,KAAK,CAAC;AACnB,UAAI,4BAA4B;AAC5B;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,aAAa,WAAW,GAAG;AAC3B,WAAO,EAAE,UAAU,CAAC,KAAK,GAAG,YAAY,CAAC,EAAE;AAAA,EAC/C;AAEA,MAAI,aAAa,aAAa,IAAI,CAAC,MAAM,MAAM,EAAE;AACjD,MAAI,WAAW,aAAa,IAAI,CAAC,UAAU,MAAM;AAC7C,UAAM,aAAa,MAAM,IAAI,IAAI,aAAa,IAAI,KAAK;AACvD,WAAO,MAAM,MAAM,YAAY,QAAQ;AAAA,EAC3C,CAAC;AACD,WAAS,KACL,MAAM,MAAM,aAAa,aAAa,SAAS,KAAK,GAAG,MAAM,MAAM,CACvE;AAEA,SAAO,EAAE,UAAU,WAAW;AAClC;;;AD9BO,sBACH,KACA,WAC+C;AAC/C,MAAI,OAAO,cAAc,UAAU;AAC/B,gBAAY,CAAC,SAAS;AAAA,EAC1B;AACA,MAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC3B,UAAM,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AACA,QAAM,cAAc,sCAAM,mBAAmB,SAAS;AACtD,QAAM,EAAE,UAAU,eAAe,iBAAiB,KAAK,WAAW;AAClE,SAAO,EAAE,UAAU,QAAQ,WAA0B;AACzD;;;AErBO,wBAAwB;AAAA,EAC3B;AAAA,EACA;AAAA,GAID;AACC,MAAI,SAAS,WAAW,GAAG;AACvB,YAAQ,KAAK,8BAA8B;AAC3C,WAAO,CAAC;AAAA,EACZ;AACA,MAAI,SAAS,WAAW,OAAO,SAAS,GAAG;AACvC,YAAQ,KACJ,wEACJ;AAAA,EACJ;AAEA,MAAI,MAAM,SAAS;AACnB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAGpC,UAAM,IAAI,OAAO,OAAO,EAAE,EAAE,OAAO,SAAS,IAAI,EAAE;AAAA,EACtD;AAEA,SAAO;AACX;;;AC3BO,mBAAsB,OAAc,KAAmB;AAC1D,SAAO,MAAM,QAAQ,CAAC,MAAM,MAAM;AAC9B,QAAI,MAAM,GAAG;AACT,aAAO;AAAA,IACX;AACA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,aAAO,CAAC,GAAG,KAAK,GAAG,IAAI;AAAA,IAC3B,OAAO;AACH,aAAO,CAAC,KAAK,GAAG,IAAI;AAAA,IACxB;AAAA,EACJ,CAAC;AACL;",
  "names": []
}
