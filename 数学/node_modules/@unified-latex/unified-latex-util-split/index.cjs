var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_split_exports = {};
__export(unified_latex_util_split_exports, {
  arrayJoin: () => arrayJoin,
  splitOnCondition: () => splitOnCondition,
  splitOnMacro: () => splitOnMacro,
  unsplitOnMacro: () => unsplitOnMacro
});
module.exports = __toCommonJS(unified_latex_util_split_exports);

// libs/split-on-macro.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");

// libs/split-on-condition.ts
function splitOnCondition(nodes, splitFunc = () => false, options) {
  if (!Array.isArray(nodes)) {
    throw new Error(`Can only split an Array, not ${nodes}`);
  }
  const { onlySplitOnFirstOccurrence = false } = options || {};
  const splitIndices = [];
  for (let i = 0; i < nodes.length; i++) {
    if (splitFunc(nodes[i])) {
      splitIndices.push(i);
      if (onlySplitOnFirstOccurrence) {
        break;
      }
    }
  }
  if (splitIndices.length === 0) {
    return { segments: [nodes], separators: [] };
  }
  let separators = splitIndices.map((i) => nodes[i]);
  let segments = splitIndices.map((splitEnd, i) => {
    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
    return nodes.slice(splitStart, splitEnd);
  });
  segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
  return { segments, separators };
}

// libs/split-on-macro.ts
function splitOnMacro(ast, macroName) {
  if (typeof macroName === "string") {
    macroName = [macroName];
  }
  if (!Array.isArray(macroName)) {
    throw new Error("Type coercion failed");
  }
  const isSeparator = import_unified_latex_util_match.match.createMacroMatcher(macroName);
  const { segments, separators } = splitOnCondition(ast, isSeparator);
  return { segments, macros: separators };
}

// libs/unsplit-on-macro.ts
function unsplitOnMacro({
  segments,
  macros
}) {
  if (segments.length === 0) {
    console.warn("Trying to join zero segments");
    return [];
  }
  if (segments.length !== macros.length + 1) {
    console.warn("Mismatch between lengths of macros and segments when trying to unsplit");
  }
  let ret = segments[0];
  for (let i = 0; i < macros.length; i++) {
    ret = ret.concat(macros[i]).concat(segments[i + 1]);
  }
  return ret;
}

// libs/array-join.ts
function arrayJoin(array, sep) {
  return array.flatMap((item, i) => {
    if (i === 0) {
      return item;
    }
    if (Array.isArray(sep)) {
      return [...sep, ...item];
    } else {
      return [sep, ...item];
    }
  });
}
//# sourceMappingURL=index.cjs.map
