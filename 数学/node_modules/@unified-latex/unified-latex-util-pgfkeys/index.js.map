{
  "version": 3,
  "sources": ["../libs/pgfkeys-parser.ts", "../libs/pgfkeys-to-object.ts"],
  "sourcesContent": ["import { PgfkeysPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\n\nexport type Item = {\n    itemParts?: Ast.Node[][];\n    trailingComment: Ast.Comment | null;\n    trailingComma?: boolean;\n    leadingParbreak?: boolean;\n};\n\nexport function createMatchers() {\n    return {\n        isComma: (node: Ast.Node) => match.string(node, \",\"),\n        isEquals: (node: Ast.Node) => match.string(node, \"=\"),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isParbreak: (node: Ast.Node) => match.parbreak(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the arguments of a Pgfkeys macro. The `ast`\n * is expected to be a comma separated list of `Item`s.\n * Each item can have 0 or more item parts, which are separated\n * by \"=\". If `itemPart` is undefined,\n *\n * @export\n * @param {Ast.Node[]} ast\n * @returns {Item[]}\n */\nexport function parsePgfkeys(ast: Ast.Node[]): Item[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return PgfkeysPegParser.parse(ast, createMatchers()) as Item[];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"./pgfkeys-parser\";\n\n/**\n * Parse `arg` as pgfkeys and return a JavaScript object with the results.\n * The keys will be normalized to strings and the values will be arrays of nodes.\n */\nexport function pgfkeysArgToObject(\n    arg: Ast.Argument | Ast.Node[]\n): Record<string, Ast.Node[]> {\n    function parseFront(nodes: Ast.Node[]): string {\n        return printRaw(nodes);\n    }\n    function parseBack(nodes: Ast.Node[] | undefined): Ast.Node[] {\n        if (!nodes) {\n            return [];\n        }\n        // If the only element is a group, we unwrap it\n        if (nodes.length === 1 && match.group(nodes[0])) {\n            return nodes[0].content;\n        }\n        return nodes;\n    }\n\n    let nodeList: Ast.Node[];\n    if (match.argument(arg)) {\n        nodeList = arg.content;\n    } else {\n        nodeList = arg;\n    }\n    const parsedArgs = parsePgfkeys(nodeList);\n    return Object.fromEntries(\n        parsedArgs\n            .filter((part) => part.itemParts)\n            .map((part) => [\n                parseFront(part.itemParts![0]),\n                parseBack(part.itemParts![1]),\n            ])\n    );\n}\n"],
  "mappings": ";AAAA;AAEA;AACA;AAWO,0BAA0B;AAC7B,SAAO;AAAA,IACH,SAAS,CAAC,SAAmB,MAAM,OAAO,MAAM,GAAG;AAAA,IACnD,UAAU,CAAC,SAAmB,MAAM,OAAO,MAAM,GAAG;AAAA,IACpD,cAAc,CAAC,SAAmB,MAAM,WAAW,IAAI;AAAA,IACvD,YAAY,CAAC,SAAmB,MAAM,SAAS,IAAI;AAAA,IACnD,mBAAmB,CAAC,SAChB,MAAM,QAAQ,IAAI,KAAK,KAAK;AAAA,IAChC,kBAAkB,CAAC,SACf,MAAM,QAAQ,IAAI,KAAK,CAAC,KAAK;AAAA,EACrC;AACJ;AAYO,sBAAsB,KAAyB;AAClD,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACrB,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAGA,QAAM,sBAAsB,CAAC,GAAG,GAAG,CAAC;AAGpC,SAAO,iBAAiB,MAAM,KAAK,eAAe,CAAC;AACvD;;;AC9CA;AACA;AAOO,4BACH,KAC0B;AAC1B,sBAAoB,OAA2B;AAC3C,WAAO,SAAS,KAAK;AAAA,EACzB;AACA,qBAAmB,OAA2C;AAC1D,QAAI,CAAC,OAAO;AACR,aAAO,CAAC;AAAA,IACZ;AAEA,QAAI,MAAM,WAAW,KAAK,OAAM,MAAM,MAAM,EAAE,GAAG;AAC7C,aAAO,MAAM,GAAG;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAEA,MAAI;AACJ,MAAI,OAAM,SAAS,GAAG,GAAG;AACrB,eAAW,IAAI;AAAA,EACnB,OAAO;AACH,eAAW;AAAA,EACf;AACA,QAAM,aAAa,aAAa,QAAQ;AACxC,SAAO,OAAO,YACV,WACK,OAAO,CAAC,SAAS,KAAK,SAAS,EAC/B,IAAI,CAAC,SAAS;AAAA,IACX,WAAW,KAAK,UAAW,EAAE;AAAA,IAC7B,UAAU,KAAK,UAAW,EAAE;AAAA,EAChC,CAAC,CACT;AACJ;",
  "names": []
}
