// libs/pgfkeys-parser.ts
import { PgfkeysPegParser } from "@unified-latex/unified-latex-util-pegjs";
import { match } from "@unified-latex/unified-latex-util-match";
import { decorateArrayForPegjs } from "@unified-latex/unified-latex-util-pegjs";
function createMatchers() {
  return {
    isComma: (node) => match.string(node, ","),
    isEquals: (node) => match.string(node, "="),
    isWhitespace: (node) => match.whitespace(node),
    isParbreak: (node) => match.parbreak(node),
    isSameLineComment: (node) => match.comment(node) && node.sameline,
    isOwnLineComment: (node) => match.comment(node) && !node.sameline
  };
}
function parsePgfkeys(ast) {
  if (!Array.isArray(ast)) {
    throw new Error("You must pass an array of nodes");
  }
  ast = decorateArrayForPegjs([...ast]);
  return PgfkeysPegParser.parse(ast, createMatchers());
}

// libs/pgfkeys-to-object.ts
import { match as match2 } from "@unified-latex/unified-latex-util-match";
import { printRaw } from "@unified-latex/unified-latex-util-print-raw";
function pgfkeysArgToObject(arg) {
  function parseFront(nodes) {
    return printRaw(nodes);
  }
  function parseBack(nodes) {
    if (!nodes) {
      return [];
    }
    if (nodes.length === 1 && match2.group(nodes[0])) {
      return nodes[0].content;
    }
    return nodes;
  }
  let nodeList;
  if (match2.argument(arg)) {
    nodeList = arg.content;
  } else {
    nodeList = arg;
  }
  const parsedArgs = parsePgfkeys(nodeList);
  return Object.fromEntries(parsedArgs.filter((part) => part.itemParts).map((part) => [
    parseFront(part.itemParts[0]),
    parseBack(part.itemParts[1])
  ]));
}
export {
  createMatchers,
  parsePgfkeys,
  pgfkeysArgToObject
};
//# sourceMappingURL=index.js.map
