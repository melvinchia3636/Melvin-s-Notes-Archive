var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_replace_exports = {};
__export(unified_latex_util_replace_exports, {
  firstSignificantNode: () => firstSignificantNode,
  firstSignificantNodeIndex: () => firstSignificantNodeIndex,
  lastSignificantNode: () => lastSignificantNode,
  lastSignificantNodeIndex: () => lastSignificantNodeIndex,
  replaceNode: () => replaceNode,
  replaceNodeDuringVisit: () => replaceNodeDuringVisit,
  replaceStreamingCommand: () => replaceStreamingCommand,
  replaceStreamingCommandInGroup: () => replaceStreamingCommandInGroup,
  unifiedLatexReplaceStreamingCommands: () => unifiedLatexReplaceStreamingCommands
});
module.exports = __toCommonJS(unified_latex_util_replace_exports);

// libs/replace-node.ts
var import_unified_latex_util_visit = require("@unified-latex/unified-latex-util-visit");
function replaceNode(ast, visitor) {
  (0, import_unified_latex_util_visit.visit)(ast, {
    leave: (node, info) => {
      let replacement = visitor(node, info.context);
      if (typeof replacement === "undefined" || replacement === node) {
        return;
      }
      if (!info.containingArray || info.index == null) {
        throw new Error("Trying to delete node, but cannot find containing array");
      }
      if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
        info.containingArray.splice(info.index, 1);
        return info.index;
      }
      if (!Array.isArray(replacement)) {
        replacement = [replacement];
      }
      info.containingArray.splice(info.index, 1, ...replacement);
      return info.index + replacement.length;
    }
  });
}

// libs/unified-latex-streaming-command.ts
var import_unified_latex_util_match5 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_trim4 = require("@unified-latex/unified-latex-util-trim");
var import_unified_latex_util_visit2 = require("@unified-latex/unified-latex-util-visit");

// libs/replace-streaming-command.ts
var import_unified_latex_util_match4 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_split = require("@unified-latex/unified-latex-util-split");
var import_unified_latex_util_trim3 = require("@unified-latex/unified-latex-util-trim");

// libs/utils/significant-node.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
function firstSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (import_unified_latex_util_match.match.whitespace(node) || import_unified_latex_util_match.match.comment(node) || parbreaksAreInsignificant && import_unified_latex_util_match.match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}
function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (import_unified_latex_util_match.match.whitespace(node) || import_unified_latex_util_match.match.comment(node) || parbreaksAreInsignificant && import_unified_latex_util_match.match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}

// libs/utils/replace-streaming-command-in-array.ts
var import_unified_latex_util_trim2 = require("@unified-latex/unified-latex-util-trim");

// libs/utils/join-without-excess-whitespace.ts
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_trim = require("@unified-latex/unified-latex-util-trim");
function isSpaceLike(node) {
  return import_unified_latex_util_match2.match.whitespace(node) || import_unified_latex_util_match2.match.comment(node) && Boolean(node.leadingWhitespace);
}
function joinWithoutExcessWhitespace(head, tail) {
  if (tail.length === 0) {
    return;
  }
  if (head.length === 0) {
    head.push(...tail);
    return;
  }
  const headEnd = head[head.length - 1];
  const tailStart = tail[0];
  if (import_unified_latex_util_match2.match.whitespace(headEnd) && import_unified_latex_util_match2.match.whitespace(tailStart)) {
    head.push(...tail.slice(1));
    return;
  }
  if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
    if (import_unified_latex_util_match2.match.whitespace(headEnd) && import_unified_latex_util_match2.match.comment(tailStart)) {
      const comment2 = {
        type: "comment",
        content: tailStart.content,
        sameline: true,
        leadingWhitespace: true
      };
      tail = tail.slice(1);
      (0, import_unified_latex_util_trim.trimStart)(tail);
      head.pop();
      head.push(comment2, ...tail);
      return;
    }
    head.push(...tail);
    return;
  }
  if (import_unified_latex_util_match2.match.comment(headEnd) && import_unified_latex_util_match2.match.comment(tailStart)) {
    if (tailStart.leadingWhitespace || tailStart.sameline) {
      head.push({ type: "comment", content: tailStart.content }, ...tail.slice(1));
      return;
    }
    head.push(...tail);
    return;
  }
  let comment = import_unified_latex_util_match2.match.comment(headEnd) ? headEnd : tailStart;
  if (!import_unified_latex_util_match2.match.comment(comment)) {
    throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);
  }
  if (!comment.leadingWhitespace || !comment.sameline) {
    comment = {
      type: "comment",
      content: comment.content,
      leadingWhitespace: true,
      sameline: true
    };
  }
  head.pop();
  head.push(comment, ...tail.slice(1));
}

// libs/utils/wrap-significant-content.ts
var import_unified_latex_util_match3 = require("@unified-latex/unified-latex-util-match");
function wrapSignificantContent(content, wrapper) {
  let hoistUntil = 0;
  let hoistAfter = content.length;
  for (let i = 0; i < content.length; i++) {
    if (import_unified_latex_util_match3.match.whitespace(content[i]) || import_unified_latex_util_match3.match.comment(content[i])) {
      hoistUntil = i + 1;
      continue;
    }
    break;
  }
  for (let j = content.length - 1; j >= 0; j--) {
    if (import_unified_latex_util_match3.match.whitespace(content[j]) || import_unified_latex_util_match3.match.comment(content[j])) {
      hoistAfter = j;
      continue;
    }
    break;
  }
  if (hoistUntil === 0 && hoistAfter === content.length) {
    return ensureArray(wrapper(content));
  }
  const frontMatter = content.slice(0, hoistUntil);
  const middle = content.slice(hoistUntil, hoistAfter);
  const backMatter = content.slice(hoistAfter, content.length);
  return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
  if (!Array.isArray(x)) {
    return [x];
  }
  return x;
}

// libs/utils/replace-streaming-command-in-array.ts
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
  while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
    nodes.pop();
    (0, import_unified_latex_util_trim2.trimEnd)(nodes);
  }
  const foundStreamingCommands = [];
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (isStreamingCommand(node)) {
      const wrapper = (content) => replacer(content, node);
      let tail = nodes.slice(i + 1);
      (0, import_unified_latex_util_trim2.trimStart)(tail);
      tail = wrapSignificantContent(tail, wrapper);
      foundStreamingCommands.push(node);
      nodes.splice(i);
      joinWithoutExcessWhitespace(nodes, tail);
    }
  }
  return { foundStreamingCommands };
}

// libs/replace-streaming-command.ts
function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer, options) {
  const content = group.content;
  let popFromGroup = isStreamingCommand(firstSignificantNode(content));
  let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer, options);
  if (innerProcessed.length === 0) {
    return [];
  }
  if (popFromGroup) {
    return innerProcessed;
  } else {
    return [{ type: "group", content: innerProcessed }];
  }
}
function replaceStreamingCommand(ast, isStreamingCommand, replacer, options) {
  if (typeof isStreamingCommand !== "function") {
    throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);
  }
  const {
    macrosThatBreakPars = [
      "part",
      "chapter",
      "section",
      "subsection",
      "subsubsection",
      "vspace",
      "smallskip",
      "medskip",
      "bigskip",
      "hfill"
    ],
    environmentsThatDontBreakPars = []
  } = options || {};
  let processedContent = [];
  if (import_unified_latex_util_match4.match.group(ast)) {
    processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);
  }
  if (Array.isArray(ast)) {
    const nodes = ast;
    let scanIndex = nodes.length;
    let sliceIndex = scanIndex;
    while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || import_unified_latex_util_match4.match.whitespace(nodes[scanIndex - 1]))) {
      scanIndex--;
      if (isStreamingCommand(nodes[scanIndex])) {
        sliceIndex = scanIndex;
      }
    }
    if (sliceIndex !== nodes.length) {
      nodes.splice(sliceIndex);
    }
    const macroThatBreaks = import_unified_latex_util_match4.match.createMacroMatcher(macrosThatBreakPars);
    const envThatDoesntBreak = import_unified_latex_util_match4.match.createEnvironmentMatcher(environmentsThatDontBreakPars);
    const isPar = (node) => import_unified_latex_util_match4.match.parbreak(node) || import_unified_latex_util_match4.match.macro(node, "par") || macroThatBreaks(node) || import_unified_latex_util_match4.match.environment(node) && !envThatDoesntBreak(node) || node.type === "displaymath";
    const splitByPar = (0, import_unified_latex_util_split.splitOnCondition)(nodes, isPar);
    splitByPar.separators = splitByPar.separators.map((sep) => import_unified_latex_util_match4.match.macro(sep, "par") ? { type: "parbreak" } : sep);
    const replacers = [];
    let segments = splitByPar.segments.map((segment) => {
      if (segment.length === 0) {
        return segment;
      }
      function applyAccumulatedReplacers(nodes2) {
        if (replacers.length === 0) {
          return nodes2;
        }
        return wrapSignificantContent(nodes2, composeReplacers(replacers));
      }
      const { foundStreamingCommands } = replaceStreamingCommandInArray(segment, isStreamingCommand, replacer);
      const ret = applyAccumulatedReplacers(segment);
      foundStreamingCommands.forEach((macro) => {
        replacers.push((nodes2) => {
          const ret2 = replacer(nodes2, macro);
          if (!Array.isArray(ret2)) {
            return [ret2];
          }
          return ret2;
        });
      });
      return ret;
    });
    if (segments.length > 1) {
      segments.forEach((segment, i) => {
        if (i === 0) {
          (0, import_unified_latex_util_trim3.trimEnd)(segment);
        } else if (i === segments.length - 1) {
          (0, import_unified_latex_util_trim3.trimStart)(segment);
        } else {
          (0, import_unified_latex_util_trim3.trim)(segment);
        }
      });
    }
    processedContent = (0, import_unified_latex_util_split.unsplitOnMacro)({
      segments,
      macros: splitByPar.separators
    });
  }
  return processedContent;
}
function composeReplacers(replacers) {
  if (replacers.length === 0) {
    throw new Error("Cannot compose zero replacement functions");
  }
  return (nodes) => {
    let ret = nodes;
    for (let i = 0; i < replacers.length; i++) {
      const func = replacers[i];
      ret = func(ret);
    }
    return ret;
  };
}

// libs/replace-node-during-visit.ts
function replaceNodeDuringVisit(replacement, info) {
  const parent = info.parents[0];
  if (!parent) {
    throw new Error(`Cannot replace node: parent not found`);
  }
  const container = parent[info.key];
  if (!Array.isArray(container)) {
    throw new Error(`Cannot replace node: containing array not found`);
  }
  if (info.index == null) {
    throw new Error(`Cannot replace node: node index undefined`);
  }
  if (!Array.isArray(replacement)) {
    container[info.index] = replacement;
  } else {
    container.splice(info.index, 1, ...replacement);
  }
}

// libs/unified-latex-streaming-command.ts
var unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options) {
  const { replacers = {} } = options || {};
  const isReplaceable = import_unified_latex_util_match5.match.createMacroMatcher(replacers);
  return (tree) => {
    (0, import_unified_latex_util_visit2.visit)(tree, (group, info) => {
      if (info.context.hasMathModeAncestor || !group.content.some(isReplaceable)) {
        return;
      }
      let fixed = replaceStreamingCommand(group, isReplaceable, (content, command) => {
        return replacers[command.content](content, command);
      });
      if (!info.containingArray || info.index == null) {
        return;
      }
      const prevToken = info.containingArray[info.index - 1];
      const nextToken = info.containingArray[info.index + 1];
      if (import_unified_latex_util_match5.match.whitespaceLike(prevToken) && import_unified_latex_util_match5.match.whitespaceLike(fixed[0])) {
        (0, import_unified_latex_util_trim4.trimStart)(fixed);
      }
      if (import_unified_latex_util_match5.match.whitespaceLike(nextToken) && import_unified_latex_util_match5.match.whitespaceLike(fixed[fixed.length - 1])) {
        (0, import_unified_latex_util_trim4.trimEnd)(fixed);
      }
      replaceNodeDuringVisit(fixed, info);
    }, { test: import_unified_latex_util_match5.match.group });
    (0, import_unified_latex_util_visit2.visit)(tree, (nodes, info) => {
      if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {
        return;
      }
      const replaced = replaceStreamingCommand(nodes, isReplaceable, (content, command) => {
        return replacers[command.content](content, command);
      });
      if (replaced !== nodes) {
        nodes.length = 0;
        nodes.push(...replaced);
      }
    }, { includeArrays: true, test: Array.isArray });
  };
};
//# sourceMappingURL=index.cjs.map
