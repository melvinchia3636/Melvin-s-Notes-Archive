// libs/replace-node.ts
import { visit } from "@unified-latex/unified-latex-util-visit";
function replaceNode(ast, visitor) {
  visit(ast, {
    leave: (node, info) => {
      let replacement = visitor(node, info.context);
      if (typeof replacement === "undefined" || replacement === node) {
        return;
      }
      if (!info.containingArray || info.index == null) {
        throw new Error("Trying to delete node, but cannot find containing array");
      }
      if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
        info.containingArray.splice(info.index, 1);
        return info.index;
      }
      if (!Array.isArray(replacement)) {
        replacement = [replacement];
      }
      info.containingArray.splice(info.index, 1, ...replacement);
      return info.index + replacement.length;
    }
  });
}

// libs/unified-latex-streaming-command.ts
import { match as match5 } from "@unified-latex/unified-latex-util-match";
import { trimEnd as trimEnd3, trimStart as trimStart4 } from "@unified-latex/unified-latex-util-trim";
import { visit as visit2 } from "@unified-latex/unified-latex-util-visit";

// libs/replace-streaming-command.ts
import { match as match4 } from "@unified-latex/unified-latex-util-match";
import {
  splitOnCondition,
  unsplitOnMacro
} from "@unified-latex/unified-latex-util-split";
import {
  trim,
  trimEnd as trimEnd2,
  trimStart as trimStart3
} from "@unified-latex/unified-latex-util-trim";

// libs/utils/significant-node.ts
import { match } from "@unified-latex/unified-latex-util-match";
function firstSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (match.whitespace(node) || match.comment(node) || parbreaksAreInsignificant && match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}
function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (match.whitespace(node) || match.comment(node) || parbreaksAreInsignificant && match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}

// libs/utils/replace-streaming-command-in-array.ts
import { trimEnd, trimStart as trimStart2 } from "@unified-latex/unified-latex-util-trim";

// libs/utils/join-without-excess-whitespace.ts
import { match as match2 } from "@unified-latex/unified-latex-util-match";
import { trimStart } from "@unified-latex/unified-latex-util-trim";
function isSpaceLike(node) {
  return match2.whitespace(node) || match2.comment(node) && Boolean(node.leadingWhitespace);
}
function joinWithoutExcessWhitespace(head, tail) {
  if (tail.length === 0) {
    return;
  }
  if (head.length === 0) {
    head.push(...tail);
    return;
  }
  const headEnd = head[head.length - 1];
  const tailStart = tail[0];
  if (match2.whitespace(headEnd) && match2.whitespace(tailStart)) {
    head.push(...tail.slice(1));
    return;
  }
  if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
    if (match2.whitespace(headEnd) && match2.comment(tailStart)) {
      const comment2 = {
        type: "comment",
        content: tailStart.content,
        sameline: true,
        leadingWhitespace: true
      };
      tail = tail.slice(1);
      trimStart(tail);
      head.pop();
      head.push(comment2, ...tail);
      return;
    }
    head.push(...tail);
    return;
  }
  if (match2.comment(headEnd) && match2.comment(tailStart)) {
    if (tailStart.leadingWhitespace || tailStart.sameline) {
      head.push({ type: "comment", content: tailStart.content }, ...tail.slice(1));
      return;
    }
    head.push(...tail);
    return;
  }
  let comment = match2.comment(headEnd) ? headEnd : tailStart;
  if (!match2.comment(comment)) {
    throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);
  }
  if (!comment.leadingWhitespace || !comment.sameline) {
    comment = {
      type: "comment",
      content: comment.content,
      leadingWhitespace: true,
      sameline: true
    };
  }
  head.pop();
  head.push(comment, ...tail.slice(1));
}

// libs/utils/wrap-significant-content.ts
import { match as match3 } from "@unified-latex/unified-latex-util-match";
function wrapSignificantContent(content, wrapper) {
  let hoistUntil = 0;
  let hoistAfter = content.length;
  for (let i = 0; i < content.length; i++) {
    if (match3.whitespace(content[i]) || match3.comment(content[i])) {
      hoistUntil = i + 1;
      continue;
    }
    break;
  }
  for (let j = content.length - 1; j >= 0; j--) {
    if (match3.whitespace(content[j]) || match3.comment(content[j])) {
      hoistAfter = j;
      continue;
    }
    break;
  }
  if (hoistUntil === 0 && hoistAfter === content.length) {
    return ensureArray(wrapper(content));
  }
  const frontMatter = content.slice(0, hoistUntil);
  const middle = content.slice(hoistUntil, hoistAfter);
  const backMatter = content.slice(hoistAfter, content.length);
  return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
  if (!Array.isArray(x)) {
    return [x];
  }
  return x;
}

// libs/utils/replace-streaming-command-in-array.ts
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
  while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
    nodes.pop();
    trimEnd(nodes);
  }
  const foundStreamingCommands = [];
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (isStreamingCommand(node)) {
      const wrapper = (content) => replacer(content, node);
      let tail = nodes.slice(i + 1);
      trimStart2(tail);
      tail = wrapSignificantContent(tail, wrapper);
      foundStreamingCommands.push(node);
      nodes.splice(i);
      joinWithoutExcessWhitespace(nodes, tail);
    }
  }
  return { foundStreamingCommands };
}

// libs/replace-streaming-command.ts
function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer, options) {
  const content = group.content;
  let popFromGroup = isStreamingCommand(firstSignificantNode(content));
  let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer, options);
  if (innerProcessed.length === 0) {
    return [];
  }
  if (popFromGroup) {
    return innerProcessed;
  } else {
    return [{ type: "group", content: innerProcessed }];
  }
}
function replaceStreamingCommand(ast, isStreamingCommand, replacer, options) {
  if (typeof isStreamingCommand !== "function") {
    throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);
  }
  const {
    macrosThatBreakPars = [
      "part",
      "chapter",
      "section",
      "subsection",
      "subsubsection",
      "vspace",
      "smallskip",
      "medskip",
      "bigskip",
      "hfill"
    ],
    environmentsThatDontBreakPars = []
  } = options || {};
  let processedContent = [];
  if (match4.group(ast)) {
    processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);
  }
  if (Array.isArray(ast)) {
    const nodes = ast;
    let scanIndex = nodes.length;
    let sliceIndex = scanIndex;
    while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || match4.whitespace(nodes[scanIndex - 1]))) {
      scanIndex--;
      if (isStreamingCommand(nodes[scanIndex])) {
        sliceIndex = scanIndex;
      }
    }
    if (sliceIndex !== nodes.length) {
      nodes.splice(sliceIndex);
    }
    const macroThatBreaks = match4.createMacroMatcher(macrosThatBreakPars);
    const envThatDoesntBreak = match4.createEnvironmentMatcher(environmentsThatDontBreakPars);
    const isPar = (node) => match4.parbreak(node) || match4.macro(node, "par") || macroThatBreaks(node) || match4.environment(node) && !envThatDoesntBreak(node) || node.type === "displaymath";
    const splitByPar = splitOnCondition(nodes, isPar);
    splitByPar.separators = splitByPar.separators.map((sep) => match4.macro(sep, "par") ? { type: "parbreak" } : sep);
    const replacers = [];
    let segments = splitByPar.segments.map((segment) => {
      if (segment.length === 0) {
        return segment;
      }
      function applyAccumulatedReplacers(nodes2) {
        if (replacers.length === 0) {
          return nodes2;
        }
        return wrapSignificantContent(nodes2, composeReplacers(replacers));
      }
      const { foundStreamingCommands } = replaceStreamingCommandInArray(segment, isStreamingCommand, replacer);
      const ret = applyAccumulatedReplacers(segment);
      foundStreamingCommands.forEach((macro) => {
        replacers.push((nodes2) => {
          const ret2 = replacer(nodes2, macro);
          if (!Array.isArray(ret2)) {
            return [ret2];
          }
          return ret2;
        });
      });
      return ret;
    });
    if (segments.length > 1) {
      segments.forEach((segment, i) => {
        if (i === 0) {
          trimEnd2(segment);
        } else if (i === segments.length - 1) {
          trimStart3(segment);
        } else {
          trim(segment);
        }
      });
    }
    processedContent = unsplitOnMacro({
      segments,
      macros: splitByPar.separators
    });
  }
  return processedContent;
}
function composeReplacers(replacers) {
  if (replacers.length === 0) {
    throw new Error("Cannot compose zero replacement functions");
  }
  return (nodes) => {
    let ret = nodes;
    for (let i = 0; i < replacers.length; i++) {
      const func = replacers[i];
      ret = func(ret);
    }
    return ret;
  };
}

// libs/replace-node-during-visit.ts
function replaceNodeDuringVisit(replacement, info) {
  const parent = info.parents[0];
  if (!parent) {
    throw new Error(`Cannot replace node: parent not found`);
  }
  const container = parent[info.key];
  if (!Array.isArray(container)) {
    throw new Error(`Cannot replace node: containing array not found`);
  }
  if (info.index == null) {
    throw new Error(`Cannot replace node: node index undefined`);
  }
  if (!Array.isArray(replacement)) {
    container[info.index] = replacement;
  } else {
    container.splice(info.index, 1, ...replacement);
  }
}

// libs/unified-latex-streaming-command.ts
var unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options) {
  const { replacers = {} } = options || {};
  const isReplaceable = match5.createMacroMatcher(replacers);
  return (tree) => {
    visit2(tree, (group, info) => {
      if (info.context.hasMathModeAncestor || !group.content.some(isReplaceable)) {
        return;
      }
      let fixed = replaceStreamingCommand(group, isReplaceable, (content, command) => {
        return replacers[command.content](content, command);
      });
      if (!info.containingArray || info.index == null) {
        return;
      }
      const prevToken = info.containingArray[info.index - 1];
      const nextToken = info.containingArray[info.index + 1];
      if (match5.whitespaceLike(prevToken) && match5.whitespaceLike(fixed[0])) {
        trimStart4(fixed);
      }
      if (match5.whitespaceLike(nextToken) && match5.whitespaceLike(fixed[fixed.length - 1])) {
        trimEnd3(fixed);
      }
      replaceNodeDuringVisit(fixed, info);
    }, { test: match5.group });
    visit2(tree, (nodes, info) => {
      if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {
        return;
      }
      const replaced = replaceStreamingCommand(nodes, isReplaceable, (content, command) => {
        return replacers[command.content](content, command);
      });
      if (replaced !== nodes) {
        nodes.length = 0;
        nodes.push(...replaced);
      }
    }, { includeArrays: true, test: Array.isArray });
  };
};
export {
  firstSignificantNode,
  firstSignificantNodeIndex,
  lastSignificantNode,
  lastSignificantNodeIndex,
  replaceNode,
  replaceNodeDuringVisit,
  replaceStreamingCommand,
  replaceStreamingCommandInGroup,
  unifiedLatexReplaceStreamingCommands
};
//# sourceMappingURL=index.js.map
