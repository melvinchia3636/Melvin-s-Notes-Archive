{
  "version": 3,
  "sources": ["../libs/replace-node.ts", "../libs/unified-latex-streaming-command.ts", "../libs/replace-streaming-command.ts", "../libs/utils/significant-node.ts", "../libs/utils/replace-streaming-command-in-array.ts", "../libs/utils/join-without-excess-whitespace.ts", "../libs/utils/wrap-significant-content.ts", "../libs/replace-node-during-visit.ts"],
  "sourcesContent": ["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit, VisitorContext } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        context: VisitorContext\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info.context);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to delete node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n", "import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as (\n        | Ast.Node\n        | Ast.Argument\n    )[];\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
