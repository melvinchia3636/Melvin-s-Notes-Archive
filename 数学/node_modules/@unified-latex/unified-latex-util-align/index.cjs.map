{
  "version": 3,
  "sources": ["../index.ts", "../libs/parse-align-environment.ts"],
  "sourcesContent": ["export * from \"./libs/parse-align-environment\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to parse an analyze \"align\" environments like `\\begin{align}...\\end{align}` or\n * `\\begin{bmatrix}...\\end{bmatrix}`.\n *\n * ## When should I use this?\n *\n * If you need to process the contents of an align environment for, e.g., pretty-printing.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    AlignEnvironmentPegParser,\n    decorateArrayForPegjs,\n} from \"@unified-latex/unified-latex-util-pegjs\";\n\n// The types returned by the grammar\ninterface RowItems {\n    cells: Ast.Node[][];\n    colSeps: Ast.String[];\n}\n\ninterface Row extends RowItems {\n    rowSep: Ast.Macro | null;\n    trailingComment: Ast.Comment | null;\n}\n\nexport function createMatchers(rowSepMacros: string[], colSep: string[]) {\n    const isRowSep = match.createMacroMatcher(rowSepMacros);\n    return {\n        isRowSep,\n        isColSep: (node: Ast.Node) =>\n            colSep.some((sep) => match.string(node, sep)),\n        isWhitespace: (node: Ast.Node) => match.whitespace(node),\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the content of an align environment into an array of row objects.\n * Each row object looks like\n * ```\n *  {\n *    cells: [...],\n *    colSeps: [...],\n *    rowSep: ...,\n *    trailingComment: ...\n *  }\n * ```\n * `...` may be an ast node or `null`.\n *\n * @export\n * @param {[object]} ast\n * @param {string} [colSep=[\"&\"]]\n * @param {string} [rowSepMacros=[\"\\\\\", \"hline\", \"cr\"]]\n * @returns\n */\nexport function parseAlignEnvironment(\n    ast: Ast.Node[],\n    colSep = [\"&\"],\n    rowSepMacros = [\"\\\\\", \"hline\", \"cr\"]\n): Row[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return AlignEnvironmentPegParser.parse(\n        ast,\n        createMatchers(rowSepMacros, colSep)\n    ) as Row[];\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,sCAAsB;AACtB,sCAGO;AAaA,wBAAwB,cAAwB,QAAkB;AACrE,QAAM,WAAW,sCAAM,mBAAmB,YAAY;AACtD,SAAO;AAAA,IACH;AAAA,IACA,UAAU,CAAC,SACP,OAAO,KAAK,CAAC,QAAQ,sCAAM,OAAO,MAAM,GAAG,CAAC;AAAA,IAChD,cAAc,CAAC,SAAmB,sCAAM,WAAW,IAAI;AAAA,IACvD,mBAAmB,CAAC,SAChB,sCAAM,QAAQ,IAAI,KAAK,KAAK;AAAA,IAChC,kBAAkB,CAAC,SACf,sCAAM,QAAQ,IAAI,KAAK,CAAC,KAAK;AAAA,EACrC;AACJ;AAqBO,+BACH,KACA,SAAS,CAAC,GAAG,GACb,eAAe,CAAC,MAAM,SAAS,IAAI,GAC9B;AACL,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACrB,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAGA,QAAM,2DAAsB,CAAC,GAAG,GAAG,CAAC;AAGpC,SAAO,0DAA0B,MAC7B,KACA,eAAe,cAAc,MAAM,CACvC;AACJ;",
  "names": []
}
