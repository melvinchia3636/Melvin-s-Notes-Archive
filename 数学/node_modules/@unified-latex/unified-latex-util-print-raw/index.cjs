var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_print_raw_exports = {};
__export(unified_latex_util_print_raw_exports, {
  linebreak: () => linebreak,
  printRaw: () => printRaw
});
module.exports = __toCommonJS(unified_latex_util_print_raw_exports);

// libs/print-raw.ts
var linebreak = Symbol("linebreak");
var ESCAPE = "\\";
function _printRaw(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(...node.map((n) => _printRaw(n)));
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw(node.content);
    case "argument":
      return [node.openMark, ..._printRaw(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw(node.content),
          suffix
        ];
      }
      return [linebreak, "%", ..._printRaw(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw(node.env);
      var envStart = [ESCAPE + "begin{", ...env, "}"];
      var envEnd = [ESCAPE + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
    case "group":
      return ["{", ..._printRaw(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw(node.args);
      escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
      return [escape, ..._printRaw(node.content), ...argsString];
    case "parbreak":
      return [linebreak, linebreak];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE,
        node.env,
        node.escape,
        ..._printRaw(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
      return ["" + node];
  }
}
function printRaw(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
}
//# sourceMappingURL=index.cjs.map
