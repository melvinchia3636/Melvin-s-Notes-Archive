{
  "version": 3,
  "sources": ["../libs/print-raw.ts"],
  "sourcesContent": ["import * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype Printable = Ast.Node | Ast.Argument | string;\ntype PrintToken = string | typeof linebreak;\n\nexport const linebreak = Symbol(\"linebreak\");\nconst ESCAPE = \"\\\\\";\n\n/**\n * Renders the AST to an array inserting `linebreak` where needed;\n * This array may be nested.\n *\n * @param {*} node\n */\nfunction _printRaw(node: Printable | Printable[]): PrintToken[] {\n    if (typeof node === \"string\") {\n        return [node];\n    }\n    if (Array.isArray(node)) {\n        return ([] as PrintToken[]).concat(\n            ...node.map((n: Printable) => _printRaw(n))\n        );\n    }\n    // tmp variables\n    let argsString, escape;\n    switch (node.type) {\n        case \"root\":\n            return _printRaw(node.content);\n        case \"argument\":\n            return [node.openMark, ..._printRaw(node.content), node.closeMark];\n        case \"comment\":\n            var suffix = node.suffixParbreak ? \"\" : linebreak;\n            // A comment is responsible for printing its own leading whitespace\n            var leadingWhitespace = \"\";\n            if (node.sameline && node.leadingWhitespace) {\n                leadingWhitespace = \" \";\n            }\n            if (node.sameline) {\n                return [\n                    leadingWhitespace,\n                    \"%\",\n                    ..._printRaw(node.content),\n                    suffix,\n                ];\n            }\n            return [linebreak, \"%\", ..._printRaw(node.content), suffix];\n        case \"environment\":\n        case \"mathenv\":\n        case \"verbatim\":\n            var env = _printRaw(node.env);\n            var envStart: PrintToken[] = [ESCAPE + \"begin{\", ...env, \"}\"];\n            var envEnd: PrintToken[] = [ESCAPE + \"end{\", ...env, \"}\"];\n            argsString =\n                (node as any).args == null ? [] : _printRaw((node as any).args);\n            return [\n                ...envStart,\n                ...argsString,\n                ..._printRaw(node.content),\n                ...envEnd,\n            ];\n        case \"displaymath\":\n            return [ESCAPE + \"[\", ..._printRaw(node.content), ESCAPE + \"]\"];\n        case \"group\":\n            return [\"{\", ..._printRaw(node.content), \"}\"];\n        case \"inlinemath\":\n            return [\"$\", ..._printRaw(node.content), \"$\"];\n        case \"macro\":\n            argsString = node.args == null ? [] : _printRaw(node.args);\n            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;\n            return [escape, ..._printRaw(node.content), ...argsString];\n        case \"parbreak\":\n            return [linebreak, linebreak];\n        case \"string\":\n            return [node.content];\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                ..._printRaw(node.content),\n                node.escape,\n            ];\n        case \"whitespace\":\n            return [\" \"];\n\n        default:\n            console.warn(\n                \"Cannot find render for node \",\n                node,\n                `(of type ${typeof node})`\n            );\n            return [\"\" + node];\n    }\n}\n\n/**\n * Renders the AST to a string without any pretty printing.\n *\n * @param {*} node\n * @param {*} options - Setting `asArray` to `true` will return an array of strings and the symbol `linebreak`, so that printing can be customized.\n */\nexport function printRaw(\n    node: Printable | Printable[],\n    options?: { asArray: false }\n): string;\nexport function printRaw(\n    node: Printable | Printable[],\n    options: { asArray: true }\n): PrintToken[];\nexport function printRaw(node: Printable | Printable[], options?: object): any {\n    const asArray = options != null ? (options as any).asArray : false;\n    const printedTokens = _printRaw(node);\n    if (asArray) {\n        return printedTokens;\n    }\n    return printedTokens.map((x) => (x === linebreak ? \"\\n\" : x)).join(\"\");\n}\n"],
  "mappings": ";AAKO,IAAM,YAAY,OAAO,WAAW;AAC3C,IAAM,SAAS;AAQf,mBAAmB,MAA6C;AAC5D,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO,CAAC,IAAI;AAAA,EAChB;AACA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,WAAQ,CAAC,EAAmB,OACxB,GAAG,KAAK,IAAI,CAAC,MAAiB,UAAU,CAAC,CAAC,CAC9C;AAAA,EACJ;AAEA,MAAI,YAAY;AAChB,UAAQ,KAAK;AAAA,SACJ;AACD,aAAO,UAAU,KAAK,OAAO;AAAA,SAC5B;AACD,aAAO,CAAC,KAAK,UAAU,GAAG,UAAU,KAAK,OAAO,GAAG,KAAK,SAAS;AAAA,SAChE;AACD,UAAI,SAAS,KAAK,iBAAiB,KAAK;AAExC,UAAI,oBAAoB;AACxB,UAAI,KAAK,YAAY,KAAK,mBAAmB;AACzC,4BAAoB;AAAA,MACxB;AACA,UAAI,KAAK,UAAU;AACf,eAAO;AAAA,UACH;AAAA,UACA;AAAA,UACA,GAAG,UAAU,KAAK,OAAO;AAAA,UACzB;AAAA,QACJ;AAAA,MACJ;AACA,aAAO,CAAC,WAAW,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,MAAM;AAAA,SACzD;AAAA,SACA;AAAA,SACA;AACD,UAAI,MAAM,UAAU,KAAK,GAAG;AAC5B,UAAI,WAAyB,CAAC,SAAS,UAAU,GAAG,KAAK,GAAG;AAC5D,UAAI,SAAuB,CAAC,SAAS,QAAQ,GAAG,KAAK,GAAG;AACxD,mBACK,KAAa,QAAQ,OAAO,CAAC,IAAI,UAAW,KAAa,IAAI;AAClE,aAAO;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG,UAAU,KAAK,OAAO;AAAA,QACzB,GAAG;AAAA,MACP;AAAA,SACC;AACD,aAAO,CAAC,SAAS,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,SAAS,GAAG;AAAA,SAC7D;AACD,aAAO,CAAC,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG;AAAA,SAC3C;AACD,aAAO,CAAC,KAAK,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG;AAAA,SAC3C;AACD,mBAAa,KAAK,QAAQ,OAAO,CAAC,IAAI,UAAU,KAAK,IAAI;AACzD,eAAS,KAAK,eAAe,OAAO,SAAS,KAAK;AAClD,aAAO,CAAC,QAAQ,GAAG,UAAU,KAAK,OAAO,GAAG,GAAG,UAAU;AAAA,SACxD;AACD,aAAO,CAAC,WAAW,SAAS;AAAA,SAC3B;AACD,aAAO,CAAC,KAAK,OAAO;AAAA,SACnB;AACD,aAAO;AAAA,QACH;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,GAAG,UAAU,KAAK,OAAO;AAAA,QACzB,KAAK;AAAA,MACT;AAAA,SACC;AACD,aAAO,CAAC,GAAG;AAAA;AAGX,cAAQ,KACJ,gCACA,MACA,YAAY,OAAO,OACvB;AACA,aAAO,CAAC,KAAK,IAAI;AAAA;AAE7B;AAgBO,kBAAkB,MAA+B,SAAuB;AAC3E,QAAM,UAAU,WAAW,OAAQ,QAAgB,UAAU;AAC7D,QAAM,gBAAgB,UAAU,IAAI;AACpC,MAAI,SAAS;AACT,WAAO;AAAA,EACX;AACA,SAAO,cAAc,IAAI,CAAC,MAAO,MAAM,YAAY,OAAO,CAAE,EAAE,KAAK,EAAE;AACzE;",
  "names": []
}
