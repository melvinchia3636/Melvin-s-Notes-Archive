{
  "version": 3,
  "sources": ["../index.ts", "../libs/process-environment.ts", "../libs/unified-latex-process-environment.ts"],
  "sourcesContent": ["export * from \"./libs/process-environment\";\nexport * from \"./libs/unified-latex-process-environment\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to report on/manipulate environments in a `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you are working on the internals of `unified-latex-util-parse` or need to make a custom parser\n * that treats environments differently.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Performs any needed processing on the environment (as specified by `envInfo`)\n * include attaching arguments and possibly manipulating the environment's body.\n */\nexport function processEnvironment(envNode: Ast.Environment, envInfo: EnvInfo) {\n    if (envInfo.signature && envNode.args == null) {\n        const { args } = gobbleArguments(envNode.content, envInfo.signature);\n        envNode.args = args;\n    }\n\n    updateRenderInfo(envNode, envInfo.renderInfo);\n    if (typeof envInfo.processContent === \"function\") {\n        envNode.content = envInfo.processContent(envNode.content);\n    }\n}\n\n/**\n * Recursively search for and process the specified environments. Arguments are\n * consumed according to the `signature` specified. The body is processed\n * with the specified `processContent` function (if given). Any specified `renderInfo`\n * is attached to the environment node.\n */\nexport function processEnvironments(\n    tree: Ast.Ast,\n    environments: EnvInfoRecord\n) {\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    visit(\n        tree,\n        {\n            leave: (node) => {\n                const envName = printRaw(node.env);\n                const envInfo = environments[envName];\n                if (!envInfo) {\n                    throw new Error(\n                        `Could not find environment info for environment \"${envName}\"`\n                    );\n                }\n                processEnvironment(node, envInfo);\n            },\n        },\n        { test: isRelevantEnvironment }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { processEnvironment } from \"./process-environment\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\ntype PluginOptions = { environments: EnvInfoRecord } | undefined;\n\n/**\n * Unified plugin to process environment content and attach arguments.\n *\n * @param environments An object whose keys are environment names and values contains information about the environment and its argument signature.\n */\nexport const unifiedLatexProcessEnvironments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {} } = options || {};\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    return (tree) => {\n        if (Object.keys(environments).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n\n        visit(\n            tree,\n            {\n                leave: (node) => {\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { test: isRelevantEnvironment }\n        );\n    };\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,4CAAiC;AACjC,0CAAgC;AAChC,sCAAsB;AACtB,sCAAsB;AACtB,0CAAyB;AAMlB,4BAA4B,SAA0B,SAAkB;AAC3E,MAAI,QAAQ,aAAa,QAAQ,QAAQ,MAAM;AAC3C,UAAM,EAAE,SAAS,yDAAgB,QAAQ,SAAS,QAAQ,SAAS;AACnE,YAAQ,OAAO;AAAA,EACnB;AAEA,8DAAiB,SAAS,QAAQ,UAAU;AAC5C,MAAI,OAAO,QAAQ,mBAAmB,YAAY;AAC9C,YAAQ,UAAU,QAAQ,eAAe,QAAQ,OAAO;AAAA,EAC5D;AACJ;AAQO,6BACH,MACA,cACF;AACE,QAAM,wBAAwB,sCAAM,yBAAyB,YAAY;AAEzE,6CACI,MACA;AAAA,IACI,OAAO,CAAC,SAAS;AACb,YAAM,UAAU,kDAAS,KAAK,GAAG;AACjC,YAAM,UAAU,aAAa;AAC7B,UAAI,CAAC,SAAS;AACV,cAAM,IAAI,MACN,oDAAoD,UACxD;AAAA,MACJ;AACA,yBAAmB,MAAM,OAAO;AAAA,IACpC;AAAA,EACJ,GACA,EAAE,MAAM,sBAAsB,CAClC;AACJ;;;ACjDA,uCAAsB;AACtB,uCAAsB;AAEtB,2CAAyB;AASlB,IAAM,kCAIT,0CAA0C,SAAS;AACnD,QAAM,EAAE,eAAe,CAAC,MAAM,WAAW,CAAC;AAC1C,QAAM,wBAAwB,uCAAM,yBAAyB,YAAY;AAEzE,SAAO,CAAC,SAAS;AACb,QAAI,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AACxC,cAAQ,KACJ,mEACJ;AAAA,IACJ;AAEA,gDACI,MACA;AAAA,MACI,OAAO,CAAC,SAAS;AACb,cAAM,UAAU,mDAAS,KAAK,GAAG;AACjC,cAAM,UAAU,aAAa;AAC7B,YAAI,CAAC,SAAS;AACV,gBAAM,IAAI,MACN,oDAAoD,UACxD;AAAA,QACJ;AACA,2BAAmB,MAAM,OAAO;AAAA,MACpC;AAAA,IACJ,GACA,EAAE,MAAM,sBAAsB,CAClC;AAAA,EACJ;AACJ;",
  "names": []
}
