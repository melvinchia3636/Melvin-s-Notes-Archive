var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_parse_exports = {};
__export(unified_latex_util_parse_exports, {
  parse: () => parse,
  parseMath: () => parseMath,
  parseMathMinimal: () => parseMathMinimal,
  parseMinimal: () => parseMinimal,
  unifiedLatexAstComplier: () => unifiedLatexAstComplier,
  unifiedLatexFromString: () => unifiedLatexFromString,
  unifiedLatexFromStringMinimal: () => unifiedLatexFromStringMinimal
});
module.exports = __toCommonJS(unified_latex_util_parse_exports);

// libs/compiler-ast.ts
var unifiedLatexAstComplier = function unifiedLatexAstComplier2() {
  Object.assign(this, { Compiler: (x) => x });
};

// libs/plugin-from-string.ts
var import_unified = require("unified");
var import_unified_latex_ctan = require("@unified-latex/unified-latex-ctan");
var import_unified_latex_util_trim = require("@unified-latex/unified-latex-util-trim");

// libs/parse-minimal.ts
var import_unified_latex_util_pegjs = require("@unified-latex/unified-latex-util-pegjs");
function parseMinimal(str) {
  return import_unified_latex_util_pegjs.LatexPegParser.parse(str);
}
function parseMathMinimal(str) {
  return import_unified_latex_util_pegjs.LatexPegParser.parse(str, { startRule: "math" });
}

// libs/plugin-from-string-minimal.ts
var unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options) {
  const parser2 = (str) => {
    if ((options == null ? void 0 : options.mode) === "math") {
      return {
        type: "root",
        content: parseMathMinimal(str),
        _renderInfo: { inMathMode: true }
      };
    }
    return parseMinimal(str);
  };
  Object.assign(this, { Parser: parser2 });
};

// libs/process-macros-and-environments.ts
var import_unified_latex_util_visit2 = require("@unified-latex/unified-latex-util-visit");
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_print_raw2 = require("@unified-latex/unified-latex-util-print-raw");

// libs/reparse-math.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_print_raw = require("@unified-latex/unified-latex-util-print-raw");
var import_unified_latex_util_visit = require("@unified-latex/unified-latex-util-visit");
function unifiedLatexReparseMathConstructPlugin({
  mathEnvs,
  mathMacros
}) {
  const isMathEnvironment = import_unified_latex_util_match.match.createEnvironmentMatcher(mathEnvs);
  const isMathMacro = import_unified_latex_util_match.match.createMacroMatcher(mathMacros);
  return (tree) => {
    (0, import_unified_latex_util_visit.visit)(tree, (node) => {
      if (import_unified_latex_util_match.match.anyMacro(node)) {
        for (const arg of node.args || []) {
          if (arg.content.length > 0 && !wasParsedInMathMode(arg.content)) {
            arg.content = parseMathMinimal((0, import_unified_latex_util_print_raw.printRaw)(arg.content));
          }
        }
      }
      if (import_unified_latex_util_match.match.anyEnvironment(node)) {
        if (!wasParsedInMathMode(node.content)) {
          node.content = parseMathMinimal((0, import_unified_latex_util_print_raw.printRaw)(node.content));
        }
      }
    }, {
      test: (node) => isMathEnvironment(node) || isMathMacro(node)
    });
  };
}
function wasParsedInMathMode(nodes) {
  return !nodes.some((node) => import_unified_latex_util_match.match.anyString(node) && node.content.length > 1 || import_unified_latex_util_match.match.string(node, "^") || import_unified_latex_util_match.match.string(node, "_"));
}

// libs/process-macros-and-environments.ts
var import_unified_latex_util_arguments = require("@unified-latex/unified-latex-util-arguments");
var import_unified_latex_util_environments = require("@unified-latex/unified-latex-util-environments");
var unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexAttachMacroArguments(options) {
  const { environments = {}, macros = {} } = options || {};
  const mathMacros = Object.fromEntries(Object.entries(macros).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
  }));
  const mathEnvs = Object.fromEntries(Object.entries(environments).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
  }));
  const mathReparser = unifiedLatexReparseMathConstructPlugin({
    mathEnvs: Object.keys(mathEnvs),
    mathMacros: Object.keys(mathMacros)
  });
  const isRelevantEnvironment = import_unified_latex_util_match2.match.createEnvironmentMatcher(environments);
  const isRelevantMathEnvironment = import_unified_latex_util_match2.match.createEnvironmentMatcher(mathEnvs);
  return (tree) => {
    (0, import_unified_latex_util_visit2.visit)(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        (0, import_unified_latex_util_arguments.attachMacroArgsInArray)(nodes, mathMacros);
      },
      leave: (node) => {
        if (!isRelevantMathEnvironment(node)) {
          return;
        }
        const envName = (0, import_unified_latex_util_print_raw2.printRaw)(node.env);
        const envInfo = environments[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        (0, import_unified_latex_util_environments.processEnvironment)(node, envInfo);
      }
    }, { includeArrays: true });
    mathReparser(tree);
    (0, import_unified_latex_util_visit2.visit)(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        (0, import_unified_latex_util_arguments.attachMacroArgsInArray)(nodes, macros);
      },
      leave: (node) => {
        if (!isRelevantEnvironment(node)) {
          return;
        }
        const envName = (0, import_unified_latex_util_print_raw2.printRaw)(node.env);
        const envInfo = environments[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        (0, import_unified_latex_util_environments.processEnvironment)(node, envInfo);
      }
    }, { includeArrays: true });
  };
};

// libs/plugin-from-string.ts
var unifiedLatexFromString = function unifiedLatexFromString2(options) {
  const {
    mode = "regular",
    macros = {},
    environments = {}
  } = options || {};
  const allMacroInfo = Object.assign({}, macros, ...Object.values(import_unified_latex_ctan.macroInfo));
  const allEnvInfo = Object.assign({}, environments, ...Object.values(import_unified_latex_ctan.environmentInfo));
  const fullParser = (0, import_unified.unified)().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {
    macros: allMacroInfo,
    environments: allEnvInfo
  }).use(import_unified_latex_util_trim.unifiedLatexTrimEnvironmentContents).use(import_unified_latex_util_trim.unifiedLatexTrimRoot).use(unifiedLatexAstComplier);
  const parser2 = (str) => {
    const file = fullParser.processSync({ value: str });
    return file.result;
  };
  Object.assign(this, { Parser: parser2 });
};

// libs/parse.ts
var import_unified2 = require("unified");
var parser = (0, import_unified2.unified)().use(unifiedLatexFromString).freeze();
function parse(str) {
  return parser.parse(str);
}

// libs/parse-math.ts
var import_unified3 = require("unified");
var import_unified_latex_util_print_raw3 = require("@unified-latex/unified-latex-util-print-raw");
function parseMath(str) {
  if (typeof str !== "string") {
    str = (0, import_unified_latex_util_print_raw3.printRaw)(str);
  }
  const file = (0, import_unified3.unified)().use(unifiedLatexFromString, { mode: "math" }).use(unifiedLatexAstComplier).processSync({ value: str });
  return file.result.content;
}
//# sourceMappingURL=index.cjs.map
