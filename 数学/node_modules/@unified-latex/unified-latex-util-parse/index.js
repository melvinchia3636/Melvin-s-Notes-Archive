// libs/compiler-ast.ts
var unifiedLatexAstComplier = function unifiedLatexAstComplier2() {
  Object.assign(this, { Compiler: (x) => x });
};

// libs/plugin-from-string.ts
import { unified } from "unified";
import { environmentInfo, macroInfo } from "@unified-latex/unified-latex-ctan";
import {
  unifiedLatexTrimEnvironmentContents,
  unifiedLatexTrimRoot
} from "@unified-latex/unified-latex-util-trim";

// libs/parse-minimal.ts
import { LatexPegParser } from "@unified-latex/unified-latex-util-pegjs";
function parseMinimal(str) {
  return LatexPegParser.parse(str);
}
function parseMathMinimal(str) {
  return LatexPegParser.parse(str, { startRule: "math" });
}

// libs/plugin-from-string-minimal.ts
var unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options) {
  const parser2 = (str) => {
    if ((options == null ? void 0 : options.mode) === "math") {
      return {
        type: "root",
        content: parseMathMinimal(str),
        _renderInfo: { inMathMode: true }
      };
    }
    return parseMinimal(str);
  };
  Object.assign(this, { Parser: parser2 });
};

// libs/process-macros-and-environments.ts
import { visit as visit2 } from "@unified-latex/unified-latex-util-visit";
import { match as match2 } from "@unified-latex/unified-latex-util-match";
import { printRaw as printRaw2 } from "@unified-latex/unified-latex-util-print-raw";

// libs/reparse-math.ts
import { match } from "@unified-latex/unified-latex-util-match";
import { printRaw } from "@unified-latex/unified-latex-util-print-raw";
import { visit } from "@unified-latex/unified-latex-util-visit";
function unifiedLatexReparseMathConstructPlugin({
  mathEnvs,
  mathMacros
}) {
  const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);
  const isMathMacro = match.createMacroMatcher(mathMacros);
  return (tree) => {
    visit(tree, (node) => {
      if (match.anyMacro(node)) {
        for (const arg of node.args || []) {
          if (arg.content.length > 0 && !wasParsedInMathMode(arg.content)) {
            arg.content = parseMathMinimal(printRaw(arg.content));
          }
        }
      }
      if (match.anyEnvironment(node)) {
        if (!wasParsedInMathMode(node.content)) {
          node.content = parseMathMinimal(printRaw(node.content));
        }
      }
    }, {
      test: (node) => isMathEnvironment(node) || isMathMacro(node)
    });
  };
}
function wasParsedInMathMode(nodes) {
  return !nodes.some((node) => match.anyString(node) && node.content.length > 1 || match.string(node, "^") || match.string(node, "_"));
}

// libs/process-macros-and-environments.ts
import { attachMacroArgsInArray } from "@unified-latex/unified-latex-util-arguments";
import { processEnvironment } from "@unified-latex/unified-latex-util-environments";
var unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexAttachMacroArguments(options) {
  const { environments = {}, macros = {} } = options || {};
  const mathMacros = Object.fromEntries(Object.entries(macros).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
  }));
  const mathEnvs = Object.fromEntries(Object.entries(environments).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
  }));
  const mathReparser = unifiedLatexReparseMathConstructPlugin({
    mathEnvs: Object.keys(mathEnvs),
    mathMacros: Object.keys(mathMacros)
  });
  const isRelevantEnvironment = match2.createEnvironmentMatcher(environments);
  const isRelevantMathEnvironment = match2.createEnvironmentMatcher(mathEnvs);
  return (tree) => {
    visit2(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        attachMacroArgsInArray(nodes, mathMacros);
      },
      leave: (node) => {
        if (!isRelevantMathEnvironment(node)) {
          return;
        }
        const envName = printRaw2(node.env);
        const envInfo = environments[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        processEnvironment(node, envInfo);
      }
    }, { includeArrays: true });
    mathReparser(tree);
    visit2(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        attachMacroArgsInArray(nodes, macros);
      },
      leave: (node) => {
        if (!isRelevantEnvironment(node)) {
          return;
        }
        const envName = printRaw2(node.env);
        const envInfo = environments[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        processEnvironment(node, envInfo);
      }
    }, { includeArrays: true });
  };
};

// libs/plugin-from-string.ts
var unifiedLatexFromString = function unifiedLatexFromString2(options) {
  const {
    mode = "regular",
    macros = {},
    environments = {}
  } = options || {};
  const allMacroInfo = Object.assign({}, macros, ...Object.values(macroInfo));
  const allEnvInfo = Object.assign({}, environments, ...Object.values(environmentInfo));
  const fullParser = unified().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {
    macros: allMacroInfo,
    environments: allEnvInfo
  }).use(unifiedLatexTrimEnvironmentContents).use(unifiedLatexTrimRoot).use(unifiedLatexAstComplier);
  const parser2 = (str) => {
    const file = fullParser.processSync({ value: str });
    return file.result;
  };
  Object.assign(this, { Parser: parser2 });
};

// libs/parse.ts
import { unified as unified2 } from "unified";
var parser = unified2().use(unifiedLatexFromString).freeze();
function parse(str) {
  return parser.parse(str);
}

// libs/parse-math.ts
import { unified as unified3 } from "unified";
import { printRaw as printRaw3 } from "@unified-latex/unified-latex-util-print-raw";
function parseMath(str) {
  if (typeof str !== "string") {
    str = printRaw3(str);
  }
  const file = unified3().use(unifiedLatexFromString, { mode: "math" }).use(unifiedLatexAstComplier).processSync({ value: str });
  return file.result.content;
}
export {
  parse,
  parseMath,
  parseMathMinimal,
  parseMinimal,
  unifiedLatexAstComplier,
  unifiedLatexFromString,
  unifiedLatexFromStringMinimal
};
//# sourceMappingURL=index.js.map
