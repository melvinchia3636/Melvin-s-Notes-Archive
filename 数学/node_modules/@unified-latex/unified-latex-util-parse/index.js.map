{
  "version": 3,
  "sources": ["../libs/compiler-ast.ts", "../libs/plugin-from-string.ts", "../libs/parse-minimal.ts", "../libs/plugin-from-string-minimal.ts", "../libs/process-macros-and-environments.ts", "../libs/reparse-math.ts", "../libs/parse.ts", "../libs/parse-math.ts"],
  "sourcesContent": ["import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Unified complier plugin that passes through a LaTeX AST without modification.\n */\nexport const unifiedLatexAstComplier: Plugin<void[], Ast.Root, Ast.Root> =\n    function unifiedLatexAstComplier() {\n        Object.assign(this, { Compiler: (x: Ast.Root) => x });\n    };\n", "import { Plugin, Parser, unified } from \"unified\";\nimport { environmentInfo, macroInfo } from \"@unified-latex/unified-latex-ctan\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord, MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport {\n    unifiedLatexTrimEnvironmentContents,\n    unifiedLatexTrimRoot,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromStringMinimal } from \"./plugin-from-string-minimal\";\nimport { unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse } from \"./process-macros-and-environments\";\n\nexport type PluginOptions =\n    | {\n          mode?: \"math\" | \"regular\";\n          macros?: MacroInfoRecord;\n          environments?: EnvInfoRecord;\n      }\n    | undefined;\n\n/**\n * Parse a string to a LaTeX AST.\n */\nexport const unifiedLatexFromString: Plugin<PluginOptions[], string, Ast.Root> =\n    function unifiedLatexFromString(options) {\n        const {\n            mode = \"regular\",\n            macros = {},\n            environments = {},\n        } = options || {};\n\n        // Build up a parsing plugin with only unified components\n        const allMacroInfo: MacroInfoRecord = Object.assign(\n            {},\n            macros,\n            ...Object.values(macroInfo)\n        );\n        const allEnvInfo: EnvInfoRecord = Object.assign(\n            {},\n            environments,\n            ...Object.values(environmentInfo)\n        );\n\n        // Build up a parser that will perform all the needed steps\n        const fullParser = unified()\n            .use(unifiedLatexFromStringMinimal, { mode })\n            // Math environments that aren't hardcoded into the PEG grammar need to be re-parsed,\n            // so do a minimal pass first with just those environments.\n            .use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {\n                macros: allMacroInfo,\n                environments: allEnvInfo,\n            })\n            .use(unifiedLatexTrimEnvironmentContents)\n            .use(unifiedLatexTrimRoot)\n            .use(unifiedLatexAstComplier);\n\n        const parser: Parser<Ast.Root> = (str) => {\n            const file = fullParser.processSync({ value: str });\n            return file.result;\n        };\n\n        Object.assign(this, { Parser: parser });\n    };\n", "import { LatexPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n */\nexport function parseMinimal(str: string): Ast.Root {\n    return LatexPegParser.parse(str);\n}\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n *\n * The parsing assumes a math-mode context, so, for example, `^` and `_` are\n * parsed as macros (even though arguments are not attached to them).\n */\nexport function parseMathMinimal(str: string): Ast.Node[] {\n    return LatexPegParser.parse(str, { startRule: \"math\" });\n}\n", "import { Plugin, Parser } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parseMathMinimal, parseMinimal } from \"./parse-minimal\";\n\ntype PluginOptions = {\n    /**\n     * Whether the text will be parsed assuming math mode or not.\n     */\n    mode: \"math\" | \"regular\";\n} | void;\n\n/**\n * Parse a string to a LaTeX AST with no post processing. For example,\n * no macro arguments will be attached, etc.\n */\nexport const unifiedLatexFromStringMinimal: Plugin<\n    PluginOptions[],\n    string,\n    Ast.Root\n> = function unifiedLatexFromStringMinimal(options) {\n    const parser: Parser<Ast.Root> = (str) => {\n        if (options?.mode === \"math\") {\n            return {\n                type: \"root\",\n                content: parseMathMinimal(str),\n                _renderInfo: { inMathMode: true },\n            };\n        }\n        return parseMinimal(str);\n    };\n\n    Object.assign(this, { Parser: parser });\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord, MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    unifiedLatexReparseMathConstructPlugin,\n} from \"./reparse-math\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { processEnvironment } from \"@unified-latex/unified-latex-util-environments\";\n\ntype PluginOptions =\n    | { environments: EnvInfoRecord; macros: MacroInfoRecord }\n    | undefined;\n\n/**\n * Unified plugin to process macros and environments. Any environments that contain math content\n * are reparsed (if needed) in math mode.\n */\nexport const unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {}, macros = {} } = options || {};\n\n    const mathMacros = Object.fromEntries(\n        Object.entries(macros).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n    const mathEnvs = Object.fromEntries(\n        Object.entries(environments).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n\n    const mathReparser = unifiedLatexReparseMathConstructPlugin({\n        mathEnvs: Object.keys(mathEnvs),\n        mathMacros: Object.keys(mathMacros),\n    });\n\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n    const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n\n    return (tree) => {\n        // First we attach all arguments/process all nodes/environments that have math content\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, mathMacros);\n                },\n                leave: (node) => {\n                    if (!isRelevantMathEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n\n        // Next we reparse macros/envs that may not have been parsed in math mode\n        mathReparser(tree);\n\n        // Now we attach all arguments/process all environment bodies\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, macros);\n                },\n                leave: (node) => {\n                    if (!isRelevantEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n    };\n};\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { parseMathMinimal } from \"./parse-minimal\";\n\ntype PluginOptions =\n    | {\n          /**\n           * List of environments whose body should be parsed in math mode\n           */\n          mathEnvs: string[];\n          /**\n           * List of macros whose bodies should be parsed in math mode\n           */\n          mathMacros: string[];\n      }\n    | undefined;\n\n/**\n * Reparse math environments/macro contents that should have been parsed in math mode but weren't.\n */\nexport const unifiedLatexReparseMath: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReparseMath(options) {\n    const { mathEnvs = [], mathMacros = [] } = options || {};\n\n    return unifiedLatexReparseMathConstructPlugin({ mathMacros, mathEnvs });\n};\n\n/**\n * Construct the inner function for the `unifiedLatexReparseMath` plugin. This function should not be used by libraries.\n */\nexport function unifiedLatexReparseMathConstructPlugin({\n    mathEnvs,\n    mathMacros,\n}: {\n    mathEnvs: string[];\n    mathMacros: string[];\n}) {\n    const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n    const isMathMacro = match.createMacroMatcher(mathMacros);\n\n    return (tree: Ast.Root) => {\n        visit(\n            tree,\n            (node) => {\n                if (match.anyMacro(node)) {\n                    for (const arg of node.args || []) {\n                        if (\n                            arg.content.length > 0 &&\n                            !wasParsedInMathMode(arg.content)\n                        ) {\n                            arg.content = parseMathMinimal(\n                                printRaw(arg.content)\n                            );\n                        }\n                    }\n                }\n                if (match.anyEnvironment(node)) {\n                    if (!wasParsedInMathMode(node.content)) {\n                        node.content = parseMathMinimal(printRaw(node.content));\n                    }\n                }\n            },\n            {\n                test: (node) => isMathEnvironment(node) || isMathMacro(node),\n            }\n        );\n    };\n}\n\n/**\n * Use a heuristic to decide whether a string was parsed in math mode. The heuristic\n * looks for strings of length greater than 1 or the failure for \"_\" and \"^\" to be parsed\n * as a macro.\n */\nfunction wasParsedInMathMode(nodes: Ast.Node[]): boolean {\n    return !nodes.some(\n        (node) =>\n            // If there are multi-char strings or ^ and _ have been parsed as strings, we know\n            // that we were not parsed in math mode.\n            (match.anyString(node) && node.content.length > 1) ||\n            match.string(node, \"^\") ||\n            match.string(node, \"_\")\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { unified } from \"unified\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\n\nconst parser = unified().use(unifiedLatexFromString).freeze();\n\n/**\n * Parse the string into an AST.\n */\nexport function parse(str: string): Ast.Root {\n    return parser.parse(str);\n}\n", "import { unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\n\n/**\n * Parse `str` into an AST. Parsing starts in math mode and a list of\n * nodes is returned (instead of a \"root\" node).\n */\nexport function parseMath(str: string | Ast.Ast): Ast.Node[] {\n    if (typeof str !== \"string\") {\n        str = printRaw(str);\n    }\n    const file = unified()\n        .use(unifiedLatexFromString, { mode: \"math\" })\n        .use(unifiedLatexAstComplier)\n        .processSync({ value: str });\n    return (file.result as Ast.Root).content;\n}\n"],
  "mappings": "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",
  "names": []
}
