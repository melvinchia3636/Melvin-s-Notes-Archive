{
  "version": 3,
  "sources": ["../index.ts", "../libs/gobble-arguments.ts", "../libs/gobble-single-argument.ts", "../libs/attach-arguments.ts", "../libs/unified-latex-attach-macro-arguments.ts", "../libs/get-args-content.ts"],
  "sourcesContent": ["export { gobbleArguments } from \"./libs/gobble-arguments\";\nexport { attachMacroArgs, attachMacroArgsInArray } from \"./libs/attach-arguments\";\nexport * from \"./libs/unified-latex-attach-macro-arguments\";\nexport * from \"./libs/get-args-content\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to help modify and attach arguments to macros in a `unified-latex` Abstract Syntax Tree (AST).\n * \n * By default, TeX doesn't actually have a concept of macro \"arguments\". Instead, TeX searches the\n * tokens after a macro and processes them according to the macro's rules. However, LaTeX attempts\n * to make macros look like functions that accept arguments. To attach the \"arguments\" to a macro\n * node, the `unified-latex` AST needs to be reparsed and manipulated.\n *\n * ## When should I use this?\n *\n * If you have custom macros that you want arguments attached to.\n * \n * If you know ahead of time which macros need arguments attached to them, use `unified-latex-util-parse`\n * and pass in the appropriate macro info instead.\n */\n", "import {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { arg } from \"@unified-latex/unified-latex-builder\";\nimport { gobbleSingleArgument } from \"./gobble-single-argument\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleArguments(\n    nodes: Ast.Node[],\n    argSpec: string | ArgSpec.Node[],\n    startPos = 0\n): {\n    args: Ast.Argument[];\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"string\") {\n        argSpec = parseArgspec(argSpec);\n    }\n\n    const args: Ast.Argument[] = [];\n    let nodesRemoved = 0;\n    for (const spec of argSpec) {\n        const { argument, nodesRemoved: removed } = gobbleSingleArgument(\n            nodes,\n            spec,\n            startPos\n        );\n        if (argument) {\n            args.push(argument);\n            nodesRemoved += removed;\n        } else {\n            args.push(arg([], { openMark: \"\", closeMark: \"\" }));\n        }\n    }\n\n    return { args, nodesRemoved };\n}\n", "import { ArgSpecAst as ArgSpec } from \"@unified-latex/unified-latex-util-argspec\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { arg } from \"@unified-latex/unified-latex-builder\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleSingleArgument(\n    nodes: Ast.Node[],\n    argSpec: ArgSpec.Node,\n    startPos = 0\n): {\n    argument: Ast.Argument | null;\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"string\" || !argSpec.type) {\n        throw new Error(\n            `argSpec must be an already-parsed argument specification, not \"${JSON.stringify(\n                argSpec\n            )}\"`\n        );\n    }\n\n    let argument: Ast.Argument | null = null;\n\n    let currPos = startPos;\n\n    // Gobble whitespace from `currPos` onward, updating `currPos`.\n    // If `argSpec` specifies leading whitespace is not allowed,\n    // this function does nothing.\n    const gobbleWhitespace = (argSpec as ArgSpec.LeadingWhitespace)\n        .noLeadingWhitespace\n        ? () => {}\n        : () => {\n              while (currPos < nodes.length) {\n                  if (!match.whitespace(nodes[currPos])) {\n                      break;\n                  }\n                  currPos++;\n              }\n          };\n\n    const openMark: string = (argSpec as any).openBrace || \"\";\n    const closeMark: string = (argSpec as any).closeBrace || \"\";\n\n    // Only mandatory arguments can be wrapped in {...}.\n    // Since we already parse such things as groups, we need to\n    // check the open and closing symbols to see if we allow for\n    // groups to be accepted as arguments\n    const acceptGroup =\n        argSpec.type === \"mandatory\" && openMark === \"{\" && closeMark === \"}\";\n\n    // Find the position of the open brace and the closing brace.\n    // The position(s) are null if the brace isn't found.\n    function findBracePositions(): [number | null, number | null] {\n        let openMarkPos: number | null = null;\n        if (openMark) {\n            openMarkPos = nodes.findIndex(\n                (node, i) => i >= currPos && match.string(node, openMark)\n            );\n            if (openMarkPos < currPos) {\n                openMarkPos = null;\n            }\n        }\n        let closeMarkPos: number | null = null;\n        if (openMarkPos != null) {\n            closeMarkPos = nodes.findIndex(\n                (node, i) =>\n                    i >= (openMarkPos as number) + 1 &&\n                    match.string(node, closeMark)\n            );\n            if (closeMarkPos < openMarkPos + 1) {\n                closeMarkPos = null;\n            }\n        }\n        return [openMarkPos, closeMarkPos];\n    }\n\n    // Do the actual matching\n    gobbleWhitespace();\n    const currNode = nodes[currPos];\n    if (\n        currNode == null ||\n        match.comment(currNode) ||\n        match.parbreak(currNode)\n    ) {\n        return { argument, nodesRemoved: 0 };\n    }\n\n    switch (argSpec.type) {\n        case \"mandatory\":\n            if (acceptGroup) {\n                let content: Ast.Node[] = [currNode];\n                if (match.group(currNode)) {\n                    // Unwrap a group if there is one.\n                    content = currNode.content;\n                }\n                argument = arg(content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            }\n        // The fallthrough here is on purpose! Matching a mandatory\n        // argument and an optional argument is the same for our purposes.\n        // We're not going to fail to parse because of a missing argument.\n        case \"optional\":\n            // We have already gobbled whitespace, so at this point, `currNode`\n            // is either an openMark or we don't have an optional argument.\n            if (match.string(currNode, openMark)) {\n                // If we're here, we have custom braces to match\n                const [openMarkPos, closeMarkPos] = findBracePositions();\n                if (openMarkPos != null && closeMarkPos != null) {\n                    argument = arg(nodes.slice(openMarkPos + 1, closeMarkPos), {\n                        openMark,\n                        closeMark,\n                    });\n                    currPos = closeMarkPos + 1;\n                    break;\n                }\n            }\n            break;\n        case \"optionalStar\":\n            if (match.string(currNode, \"*\")) {\n                argument = arg([currNode], { openMark: \"\", closeMark: \"\" });\n                currPos++;\n                break;\n            }\n            break;\n        default:\n            console.warn(\n                `Don't know how to find an argument of argspec type \"${argSpec.type}\"`\n            );\n    }\n\n    // `currPos` is has already stepped past any whitespace. However,\n    // if we did not consume an argument, we don't want to consume the whitespace.\n    const nodesRemoved = argument ? currPos - startPos : 0;\n    nodes.splice(startPos, nodesRemoved);\n    return { argument, nodesRemoved };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"./gobble-arguments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Search (in a right-associative way) through the array for instances of\n * `macros` and attach arguments to the macro. Argument signatures are\n * specified by `macros[].signature`.\n *\n * Info stored in `macros[].renderInfo` will be attached to the node\n * with attribute `_renderInfo`.\n */\nexport function attachMacroArgsInArray(\n    nodes: Ast.Node[],\n    macros: MacroInfoRecord\n): void {\n    // Some preliminaries that are only used if `ast` is an array.\n    let currIndex: number;\n\n    /**\n     * Determine whether `node` matches one of the macros in `macros`.\n     * Care is taken when matching because not all macros have\n     * `\\` as their escape token.\n     */\n    const isRelevantMacro = match.createMacroMatcher(macros);\n\n    function gobbleUntilMacro() {\n        // Step backwards until we find the required macro\n        while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {\n            currIndex--;\n        }\n    }\n\n    // Search for an occurrence of any of the macros `macroName` and its arguments.\n    // Some macros are right-associative, so we should start searching from\n    // the right\n    currIndex = nodes.length - 1;\n    while (currIndex >= 0) {\n        gobbleUntilMacro();\n        if (currIndex < 0) {\n            // We didn't find an occurrence of the macro\n            return;\n        }\n\n        // Store the currIndex, which is where the macro is. Start searching\n        // for its arguments at the next index.\n        const macroIndex = currIndex;\n        const macro = nodes[macroIndex] as Ast.Macro;\n        const macroName = macro.content;\n        const macroInfo = macros[macroName];\n\n        // Add `._renderInfo` if we have any\n        updateRenderInfo(macro, macroInfo.renderInfo);\n\n        // If the macro has no signature, it shouldn't consume any arguments. Just move along.\n        // Node: It is important that this happens *after* `updateRenderInfo` is called, since\n        // we still want to update the render info even if there are no args.\n        if (macroInfo.signature == null) {\n            currIndex--;\n            continue;\n        }\n\n        // We don't want to search for macro arguments if we already\n        // found them. If the macro has arguments, we assume that\n        // they've already been attached\n        if (macro.args != null) {\n            currIndex = macroIndex - 1;\n            continue;\n        }\n\n        // `currIndex` is the position of the macro. We want to start\n        // looking for the arguments right after the macro\n        currIndex++;\n        const { args } = gobbleArguments(nodes, macroInfo.signature, currIndex);\n        macro.args = args;\n        // After we've gobbled the arguments, set\n        // ourselves one space before the macro so we can continue.\n        currIndex = macroIndex - 1;\n    }\n}\n\n/**\n * Recursively search for and attach the arguments for a\n * particular macro to its AST node. `macros` should\n * contain a `signature` property which specifies the arguments\n * signature in xparse syntax.\n */\nexport function attachMacroArgs(tree: Ast.Ast, macros: MacroInfoRecord) {\n    visit(\n        tree,\n        (nodes) => {\n            attachMacroArgsInArray(nodes, macros);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { attachMacroArgsInArray } from \"./attach-arguments\";\n\ntype PluginOptions = { macros: MacroInfoRecord } | undefined;\n\n/**\n * Unified plugin to attach macro arguments to the macros specified via the `macros`\n * option.\n *\n * @param macros An object whose keys are macro names and values contains information about the macro and its argument signature.\n */\nexport const unifiedLatexAttachMacroArguments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree) => {\n        const { macros = {} } = options || {};\n        if (Object.keys(macros).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n        visit(\n            tree,\n            (nodes) => {\n                attachMacroArgsInArray(nodes, macros);\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Returns the content of `args` for a macro or environment as an array. If an argument\n * was omitted (e.g., because it was an optional arg that wasn't included), then `null` is returned.\n */\nexport function getArgsContent(\n    node: Ast.Macro | Ast.Environment\n): (Ast.Node[] | null)[] {\n    if (!Array.isArray(node.args)) {\n        return [];\n    }\n\n    return node.args.map((arg) => {\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            return null;\n        }\n        return arg.content;\n    });\n}\n"],
  "mappings": "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",
  "names": []
}
