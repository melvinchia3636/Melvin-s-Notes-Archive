var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_arguments_exports = {};
__export(unified_latex_util_arguments_exports, {
  attachMacroArgs: () => attachMacroArgs,
  attachMacroArgsInArray: () => attachMacroArgsInArray,
  getArgsContent: () => getArgsContent,
  gobbleArguments: () => gobbleArguments,
  unifiedLatexAttachMacroArguments: () => unifiedLatexAttachMacroArguments
});
module.exports = __toCommonJS(unified_latex_util_arguments_exports);

// libs/gobble-arguments.ts
var import_unified_latex_util_argspec = require("@unified-latex/unified-latex-util-argspec");
var import_unified_latex_builder2 = require("@unified-latex/unified-latex-builder");

// libs/gobble-single-argument.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_builder = require("@unified-latex/unified-latex-builder");
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(`argSpec must be an already-parsed argument specification, not "${JSON.stringify(argSpec)}"`);
  }
  let argument = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!import_unified_latex_util_match.match.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = argSpec.type === "mandatory" && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex((node, i) => i >= currPos && import_unified_latex_util_match.match.string(node, openMark));
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex((node, i) => i >= openMarkPos + 1 && import_unified_latex_util_match.match.string(node, closeMark));
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || import_unified_latex_util_match.match.comment(currNode) || import_unified_latex_util_match.match.parbreak(currNode)) {
    return { argument, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (import_unified_latex_util_match.match.group(currNode)) {
          content = currNode.content;
        }
        argument = (0, import_unified_latex_builder.arg)(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (import_unified_latex_util_match.match.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument = (0, import_unified_latex_builder.arg)(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
      if (import_unified_latex_util_match.match.string(currNode, "*")) {
        argument = (0, import_unified_latex_builder.arg)([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    default:
      console.warn(`Don't know how to find an argument of argspec type "${argSpec.type}"`);
  }
  const nodesRemoved = argument ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument, nodesRemoved };
}

// libs/gobble-arguments.ts
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string") {
    argSpec = (0, import_unified_latex_util_argspec.parse)(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, spec, startPos);
    if (argument) {
      args.push(argument);
      nodesRemoved += removed;
    } else {
      args.push((0, import_unified_latex_builder2.arg)([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}

// libs/attach-arguments.ts
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_render_info = require("@unified-latex/unified-latex-util-render-info");
var import_unified_latex_util_visit = require("@unified-latex/unified-latex-util-visit");
function attachMacroArgsInArray(nodes, macros) {
  let currIndex;
  const isRelevantMacro = import_unified_latex_util_match2.match.createMacroMatcher(macros);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro = nodes[macroIndex];
    const macroName = macro.content;
    const macroInfo = macros[macroName];
    (0, import_unified_latex_util_render_info.updateRenderInfo)(macro, macroInfo.renderInfo);
    if (macroInfo.signature == null) {
      currIndex--;
      continue;
    }
    if (macro.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, macroInfo.signature, currIndex);
    macro.args = args;
    currIndex = macroIndex - 1;
  }
}
function attachMacroArgs(tree, macros) {
  (0, import_unified_latex_util_visit.visit)(tree, (nodes) => {
    attachMacroArgsInArray(nodes, macros);
  }, { includeArrays: true, test: Array.isArray });
}

// libs/unified-latex-attach-macro-arguments.ts
var import_unified_latex_util_visit2 = require("@unified-latex/unified-latex-util-visit");
var unifiedLatexAttachMacroArguments = function unifiedLatexAttachMacroArguments2(options) {
  return (tree) => {
    const { macros = {} } = options || {};
    if (Object.keys(macros).length === 0) {
      console.warn("Attempting to attach macro arguments but no macros are specified.");
    }
    (0, import_unified_latex_util_visit2.visit)(tree, (nodes) => {
      attachMacroArgsInArray(nodes, macros);
    }, { includeArrays: true, test: Array.isArray });
  };
};

// libs/get-args-content.ts
function getArgsContent(node) {
  if (!Array.isArray(node.args)) {
    return [];
  }
  return node.args.map((arg3) => {
    if (arg3.openMark === "" && arg3.content.length === 0) {
      return null;
    }
    return arg3.content;
  });
}
//# sourceMappingURL=index.cjs.map
