// libs/gobble-arguments.ts
import {
  parse as parseArgspec
} from "@unified-latex/unified-latex-util-argspec";
import { arg as arg2 } from "@unified-latex/unified-latex-builder";

// libs/gobble-single-argument.ts
import { match } from "@unified-latex/unified-latex-util-match";
import { arg } from "@unified-latex/unified-latex-builder";
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(`argSpec must be an already-parsed argument specification, not "${JSON.stringify(argSpec)}"`);
  }
  let argument = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!match.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = argSpec.type === "mandatory" && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex((node, i) => i >= currPos && match.string(node, openMark));
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex((node, i) => i >= openMarkPos + 1 && match.string(node, closeMark));
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match.comment(currNode) || match.parbreak(currNode)) {
    return { argument, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (match.group(currNode)) {
          content = currNode.content;
        }
        argument = arg(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (match.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument = arg(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
      if (match.string(currNode, "*")) {
        argument = arg([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    default:
      console.warn(`Don't know how to find an argument of argspec type "${argSpec.type}"`);
  }
  const nodesRemoved = argument ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument, nodesRemoved };
}

// libs/gobble-arguments.ts
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string") {
    argSpec = parseArgspec(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, spec, startPos);
    if (argument) {
      args.push(argument);
      nodesRemoved += removed;
    } else {
      args.push(arg2([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}

// libs/attach-arguments.ts
import { match as match2 } from "@unified-latex/unified-latex-util-match";
import { updateRenderInfo } from "@unified-latex/unified-latex-util-render-info";
import { visit } from "@unified-latex/unified-latex-util-visit";
function attachMacroArgsInArray(nodes, macros) {
  let currIndex;
  const isRelevantMacro = match2.createMacroMatcher(macros);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro = nodes[macroIndex];
    const macroName = macro.content;
    const macroInfo = macros[macroName];
    updateRenderInfo(macro, macroInfo.renderInfo);
    if (macroInfo.signature == null) {
      currIndex--;
      continue;
    }
    if (macro.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, macroInfo.signature, currIndex);
    macro.args = args;
    currIndex = macroIndex - 1;
  }
}
function attachMacroArgs(tree, macros) {
  visit(tree, (nodes) => {
    attachMacroArgsInArray(nodes, macros);
  }, { includeArrays: true, test: Array.isArray });
}

// libs/unified-latex-attach-macro-arguments.ts
import { visit as visit2 } from "@unified-latex/unified-latex-util-visit";
var unifiedLatexAttachMacroArguments = function unifiedLatexAttachMacroArguments2(options) {
  return (tree) => {
    const { macros = {} } = options || {};
    if (Object.keys(macros).length === 0) {
      console.warn("Attempting to attach macro arguments but no macros are specified.");
    }
    visit2(tree, (nodes) => {
      attachMacroArgsInArray(nodes, macros);
    }, { includeArrays: true, test: Array.isArray });
  };
};

// libs/get-args-content.ts
function getArgsContent(node) {
  if (!Array.isArray(node.args)) {
    return [];
  }
  return node.args.map((arg3) => {
    if (arg3.openMark === "" && arg3.content.length === 0) {
      return null;
    }
    return arg3.content;
  });
}
export {
  attachMacroArgs,
  attachMacroArgsInArray,
  getArgsContent,
  gobbleArguments,
  unifiedLatexAttachMacroArguments
};
//# sourceMappingURL=index.js.map
