import type * as Ast from "@unified-latex/unified-latex-types";
declare type CoercibleNode = string | Ast.Node;
declare type CoercibleArgument = CoercibleNode | Ast.Argument;
declare type MacroSpecialOptions = {
    escapeToken?: string;
};
declare type ArgumentsSpecialOptions = {
    braces?: string;
    defaultOpenMark?: string;
    defaultCloseMark?: string;
};
declare type ArgumentSpecialOptions = {
    braces?: string;
    openMark?: string;
    closeMark?: string;
};
/**
 * Create an Argument list. `special.braces` can optionally specify
 * the signature of the open/close marks that each argument uses. For example
 * ```
 * args(["a", "b"], { braces: "[]{}" });
 * ```
 * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, and `(`.
 */
export declare function args(args: CoercibleArgument | CoercibleArgument[], special?: ArgumentsSpecialOptions): Ast.Argument[];
/**
 * Create an Argument. `special.braces` can optionally specify
 * the signature of the open/close marks that each argument uses. For example
 * ```
 * arg("a", { braces: "[]" });
 * ```
 * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, and `(`.
 */
export declare function arg(args: CoercibleArgument | Ast.Node[], special?: ArgumentSpecialOptions): Ast.Argument;
/**
 * Create a Macro with the given `name`. The macro
 * may be followed by any number of arguments.
 */
export declare function m(name: string, marcoArgs?: CoercibleArgument | CoercibleArgument[], special?: MacroSpecialOptions): Ast.Macro;
/**
 * Create a String node from `value`
 */
export declare function s(value: string | Ast.String): Ast.String;
/**
 * Create an Environment node.
 */
export declare function env(name: string, body: CoercibleNode | CoercibleNode[], envArgs?: CoercibleArgument | CoercibleArgument[], special?: unknown): Ast.Environment;
/**
 * Whitespace node.
 */
export declare const SP: Ast.Whitespace;
export {};
//# sourceMappingURL=builders.d.ts.map