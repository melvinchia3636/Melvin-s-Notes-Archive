{
  "version": 3,
  "sources": ["../libs/argspec-parser.ts", "../libs/argspec-types.ts"],
  "sourcesContent": ["import { ArgSpecPegParser as PegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as ArgSpec from \"./argspec-types\";\n\n/**\n * Produce a string containing any decorators for the argspec node.\n * For example, `!` in front of a node means \"don't accept leading whitespace\"\n */\nfunction getDecorators(node: ArgSpec.Node): string {\n    let ret = \"\";\n    if ((node as ArgSpec.LeadingWhitespace).noLeadingWhitespace) {\n        ret += \"!\";\n    }\n    return ret;\n}\n\n/**\n * Print an `xparse` argument specification AST\n * to a string.\n */\nexport function printRaw(node: ArgSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    const decorators = getDecorators(node);\n    const defaultArg = (node as ArgSpec.DefaultArgument).defaultArg\n        ? printRaw((node as ArgSpec.DefaultArgument).defaultArg)\n        : \"\";\n    let spec = decorators;\n\n    switch (node.type) {\n        case \"body\":\n            return decorators + \"b\";\n        case \"optionalStar\":\n            return decorators + \"s\";\n        case \"optionalToken\":\n            return spec + \"t\" + node.token;\n        case \"optional\":\n            // [...] is the default enclosure for optional arguments\n            if (node.openBrace === \"[\" && node.closeBrace === \"]\") {\n                spec += node.defaultArg ? \"O\" : \"o\";\n            } else {\n                spec += node.defaultArg ? \"D\" : \"d\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"mandatory\":\n            // {...} is the default enclosure for mandatory arguments\n            if (node.openBrace === \"{\" && node.closeBrace === \"}\") {\n                spec += \"m\";\n            } else {\n                spec += node.defaultArg ? \"R\" : \"r\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"embellishment\":\n            spec += node.defaultArg ? \"E\" : \"e\";\n            return (\n                spec +\n                \"{\" +\n                printRaw(node.embellishmentTokens) +\n                \"}\" +\n                defaultArg\n            );\n        case \"verbatim\":\n            return spec + \"v\" + node.openBrace;\n        case \"group\":\n            return spec + \"{\" + printRaw(node.content) + \"}\";\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n\nconst parseCache: { [argStr: string]: ArgSpec.Node[] } = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): ArgSpec.Node[] {\n    parseCache[str] = parseCache[str] || PegParser.parse(str);\n    return parseCache[str];\n}\n", "export type Ast = Node[] | Node;\nexport type Node = Optional | Mandatory | Verbatim | Body | Group | string;\ntype Optional = OptionalArg | OptionalStar | OptionalToken | Embellishment;\ninterface AstNode {\n    type: string;\n}\ninterface Arg extends AstNode {\n    openBrace: string;\n    closeBrace: string;\n}\nexport interface LeadingWhitespace {\n    noLeadingWhitespace: boolean | undefined;\n}\nexport interface DefaultArgument {\n    defaultArg: Group;\n}\ninterface Verbatim extends Arg {\n    type: \"verbatim\";\n}\ninterface OptionalArg extends LeadingWhitespace, DefaultArgument, Arg {\n    type: \"optional\";\n}\ninterface OptionalStar extends LeadingWhitespace, AstNode {\n    type: \"optionalStar\";\n}\ninterface OptionalToken extends LeadingWhitespace, AstNode {\n    type: \"optionalToken\";\n    token: string;\n}\ninterface Embellishment extends DefaultArgument, AstNode {\n    type: \"embellishment\";\n    embellishmentTokens: string[];\n}\ninterface Mandatory extends LeadingWhitespace, DefaultArgument, Arg {\n    type: \"mandatory\";\n}\ninterface Group extends AstNode {\n    type: \"group\";\n    content: (Group | string)[];\n}\ninterface Body extends AstNode {\n    type: \"body\";\n}\n"],
  "mappings": ";AAAA;AAOA,uBAAuB,MAA4B;AAC/C,MAAI,MAAM;AACV,MAAK,KAAmC,qBAAqB;AACzD,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAMO,kBAAkB,MAAmB,OAAO,OAAe;AAC9D,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO;AAAA,EACX;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,UAAM,WAAW,OAAO,MAAM;AAC9B,WAAO,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,KAAK,QAAQ;AAAA,EACzD;AAEA,QAAM,aAAa,cAAc,IAAI;AACrC,QAAM,aAAc,KAAiC,aAC/C,SAAU,KAAiC,UAAU,IACrD;AACN,MAAI,OAAO;AAEX,UAAQ,KAAK;AAAA,SACJ;AACD,aAAO,aAAa;AAAA,SACnB;AACD,aAAO,aAAa;AAAA,SACnB;AACD,aAAO,OAAO,MAAM,KAAK;AAAA,SACxB;AAED,UAAI,KAAK,cAAc,OAAO,KAAK,eAAe,KAAK;AACnD,gBAAQ,KAAK,aAAa,MAAM;AAAA,MACpC,OAAO;AACH,gBAAQ,KAAK,aAAa,MAAM;AAChC,gBAAQ,KAAK,YAAY,KAAK;AAAA,MAClC;AACA,aAAO,OAAO;AAAA,SACb;AAED,UAAI,KAAK,cAAc,OAAO,KAAK,eAAe,KAAK;AACnD,gBAAQ;AAAA,MACZ,OAAO;AACH,gBAAQ,KAAK,aAAa,MAAM;AAChC,gBAAQ,KAAK,YAAY,KAAK;AAAA,MAClC;AACA,aAAO,OAAO;AAAA,SACb;AACD,cAAQ,KAAK,aAAa,MAAM;AAChC,aACI,OACA,MACA,SAAS,KAAK,mBAAmB,IACjC,MACA;AAAA,SAEH;AACD,aAAO,OAAO,MAAM,KAAK;AAAA,SACxB;AACD,aAAO,OAAO,MAAM,SAAS,KAAK,OAAO,IAAI;AAAA;AAG7C,cAAQ,KACJ,sBAAuB,KAAa,kBACpC,IACJ;AACA,aAAO;AAAA;AAEnB;AAEA,IAAM,aAAmD,CAAC;AASnD,eAAe,MAAM,IAAoB;AAC5C,aAAW,OAAO,WAAW,QAAQ,UAAU,MAAM,GAAG;AACxD,SAAO,WAAW;AACtB;;;AC/FA;",
  "names": []
}
