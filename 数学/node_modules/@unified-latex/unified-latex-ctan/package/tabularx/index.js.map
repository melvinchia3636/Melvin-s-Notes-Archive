{
  "version": 3,
  "sources": ["../../../package/tabularx/provides.ts", "../../../package/tabularx/libs/parser.ts", "../../../package/tabularx/libs/print-raw.ts"],
  "sourcesContent": ["import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {};\n\nexport const environments: EnvInfoRecord = {\n    tabularx: { signature: \"m o m\", renderInfo: { alignContent: true } },\n};\n", "import { TabularPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    decorateArrayForPegjs,\n    splitStringsIntoSingleChars,\n} from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as TabularSpec from \"./types\";\n\nfunction createMatchers() {\n    return {\n        matchChar: (node: Ast.Node, char: string) => match.string(node, char),\n        isWhitespace: match.whitespace,\n        isGroup: match.group,\n    };\n}\n\n/**\n * Parse a tabular/tabularx specification, e.g. `\"|c|r|r|\"`. This parser assumes the specification has\n * already been parsed as LaTeX.\n */\nexport function parseTabularSpec(ast: Ast.Node[]): TabularSpec.TabularColumn[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // All tabular spec commands are single letters, so we pre-split all strings\n    // for easy parsing.\n    ast = splitStringsIntoSingleChars(ast);\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return TabularPegParser.parse(ast, createMatchers());\n}\n", "import * as TabularSpec from \"./types\";\nimport { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Print a tabular/tabularx argument specification AST to a string.\n */\nexport function printRaw(node: TabularSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"vert_divider\":\n            return \"|\";\n        case \"at_divider\":\n            return `@{${latexPrintRaw(node.content)}}`;\n        case \"bang_divider\":\n            return `!{${latexPrintRaw(node.content)}}`;\n        case \"alignment\":\n            if (node.alignment === \"left\") {\n                return \"l\";\n            }\n            if (node.alignment === \"right\") {\n                return \"r\";\n            }\n            if (node.alignment === \"center\") {\n                return \"c\";\n            }\n            if (node.alignment === \"X\") {\n                return \"X\";\n            }\n            if (node.alignment === \"parbox\") {\n                if (node.baseline === \"top\") {\n                    return `p{${latexPrintRaw(node.size)}}`;\n                }\n                if (node.baseline === \"default\") {\n                    return `m{${latexPrintRaw(node.size)}}`;\n                }\n                if (node.baseline === \"bottom\") {\n                    return `b{${latexPrintRaw(node.size)}}`;\n                }\n                return `w{${latexPrintRaw(node.baseline)}}{${latexPrintRaw(\n                    node.size\n                )}}`;\n            }\n            break;\n        case \"decl_code\":\n            return latexPrintRaw(node.code);\n\n        case \"column\":\n            const end_code = node.before_end_code\n                ? `<{${printRaw(node.before_end_code)}}`\n                : \"\";\n            const start_code = node.before_start_code\n                ? `>{${printRaw(node.before_start_code)}}`\n                : \"\";\n            return [\n                printRaw(node.pre_dividers),\n                start_code,\n                printRaw(node.alignment),\n                end_code,\n                printRaw(node.post_dividers),\n            ].join(\"\");\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n    return \"\";\n}\n"],
  "mappings": ";AAEO,IAAM,SAA0B,CAAC;AAEjC,IAAM,eAA8B;AAAA,EACvC,UAAU,EAAE,WAAW,SAAS,YAAY,EAAE,cAAc,KAAK,EAAE;AACvE;;;ACNA;AAEA;AACA;AAAA;AAAA;AAAA;AAMA,0BAA0B;AACtB,SAAO;AAAA,IACH,WAAW,CAAC,MAAgB,SAAiB,MAAM,OAAO,MAAM,IAAI;AAAA,IACpE,cAAc,MAAM;AAAA,IACpB,SAAS,MAAM;AAAA,EACnB;AACJ;AAMO,0BAA0B,KAA8C;AAC3E,MAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACrB,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAGA,QAAM,4BAA4B,GAAG;AAGrC,QAAM,sBAAsB,CAAC,GAAG,GAAG,CAAC;AAGpC,SAAO,iBAAiB,MAAM,KAAK,eAAe,CAAC;AACvD;;;ACjCA;AAKO,kBAAkB,MAAuB,OAAO,OAAe;AAClE,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO;AAAA,EACX;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,UAAM,WAAW,OAAO,MAAM;AAC9B,WAAO,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,KAAK,QAAQ;AAAA,EACzD;AAEA,UAAQ,KAAK;AAAA,SACJ;AACD,aAAO;AAAA,SACN;AACD,aAAO,KAAK,cAAc,KAAK,OAAO;AAAA,SACrC;AACD,aAAO,KAAK,cAAc,KAAK,OAAO;AAAA,SACrC;AACD,UAAI,KAAK,cAAc,QAAQ;AAC3B,eAAO;AAAA,MACX;AACA,UAAI,KAAK,cAAc,SAAS;AAC5B,eAAO;AAAA,MACX;AACA,UAAI,KAAK,cAAc,UAAU;AAC7B,eAAO;AAAA,MACX;AACA,UAAI,KAAK,cAAc,KAAK;AACxB,eAAO;AAAA,MACX;AACA,UAAI,KAAK,cAAc,UAAU;AAC7B,YAAI,KAAK,aAAa,OAAO;AACzB,iBAAO,KAAK,cAAc,KAAK,IAAI;AAAA,QACvC;AACA,YAAI,KAAK,aAAa,WAAW;AAC7B,iBAAO,KAAK,cAAc,KAAK,IAAI;AAAA,QACvC;AACA,YAAI,KAAK,aAAa,UAAU;AAC5B,iBAAO,KAAK,cAAc,KAAK,IAAI;AAAA,QACvC;AACA,eAAO,KAAK,cAAc,KAAK,QAAQ,MAAM,cACzC,KAAK,IACT;AAAA,MACJ;AACA;AAAA,SACC;AACD,aAAO,cAAc,KAAK,IAAI;AAAA,SAE7B;AACD,YAAM,WAAW,KAAK,kBAChB,KAAK,SAAS,KAAK,eAAe,OAClC;AACN,YAAM,aAAa,KAAK,oBAClB,KAAK,SAAS,KAAK,iBAAiB,OACpC;AACN,aAAO;AAAA,QACH,SAAS,KAAK,YAAY;AAAA,QAC1B;AAAA,QACA,SAAS,KAAK,SAAS;AAAA,QACvB;AAAA,QACA,SAAS,KAAK,aAAa;AAAA,MAC/B,EAAE,KAAK,EAAE;AAAA;AAGT,cAAQ,KACJ,sBAAuB,KAAa,kBACpC,IACJ;AACA,aAAO;AAAA;AAEf,SAAO;AACX;",
  "names": []
}
