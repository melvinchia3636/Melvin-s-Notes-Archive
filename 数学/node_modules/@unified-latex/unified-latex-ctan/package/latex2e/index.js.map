{
  "version": 3,
  "sources": ["../../../package/latex2e/provides.ts", "../../../utils/enumerate.ts", "../../../../unified-latex-util-replace/libs/replace-node.ts", "../../../../unified-latex-util-replace/libs/unified-latex-streaming-command.ts", "../../../../unified-latex-util-replace/libs/replace-streaming-command.ts", "../../../../unified-latex-util-replace/libs/utils/significant-node.ts", "../../../../unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts", "../../../../unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts", "../../../../unified-latex-util-replace/libs/utils/wrap-significant-content.ts", "../../../../unified-latex-util-replace/libs/replace-node-during-visit.ts"],
  "sourcesContent": ["import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    // Special\n    \"\\\\\": { signature: \"!s o\" },\n    _: { signature: \"m\", escapeToken: \"\" },\n    \"^\": { signature: \"m\", escapeToken: \"\" },\n    // \\newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands\n    // List can be found in latex2e.pdf \"An unofficial reference manual\"\n    newcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    renewcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    providecommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    newcounter: {\n        signature: \"m o\",\n        renderInfo: { breakAround: true },\n    },\n    usecounter: {\n        signature: \"m\",\n    },\n    setcounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    addtocounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    stepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    refstepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    // Lengths\n    newlength: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    addtolength: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settodepth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settoheight: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settowidth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Spaces\n    stretch: { signature: \"m\" },\n    hspace: { signature: \"s m\" },\n    vspace: { signature: \"s m\", renderInfo: { breakAround: true } },\n    vfill: { renderInfo: { breakAround: true } },\n    indent: { renderInfo: { breakAround: true } },\n    phantom: { signature: \"m\" },\n    vphantom: { signature: \"m\" },\n    hphantom: { signature: \"m\" },\n    noindent: { renderInfo: { breakAround: true } },\n    smallskip: { renderInfo: { breakAround: true } },\n    medskip: { renderInfo: { breakAround: true } },\n    bigskip: { renderInfo: { breakAround: true } },\n    smallbreak: { renderInfo: { breakAround: true } },\n    medbreak: { renderInfo: { breakAround: true } },\n    bigbreak: { renderInfo: { breakAround: true } },\n    newline: { renderInfo: { breakAround: true } },\n    linebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nolinebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    clearpage: { renderInfo: { breakAround: true } },\n    cleardoublepage: { renderInfo: { breakAround: true } },\n    newpage: { renderInfo: { breakAround: true } },\n    enlargethispage: { signature: \"s\", renderInfo: { breakAround: true } },\n    pagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nopagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    // Boxes\n    newsavebox: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    sbox: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    savebox: {\n        signature: \"m o o m\",\n        renderInfo: { breakAround: true },\n    },\n    mbox: { signature: \"m\" },\n    makebox: { signature: \"d() o o m\", renderInfo: { breakAround: true } },\n    fbox: { signature: \"m\" },\n    framebox: { signature: \"o o m\", renderInfo: { breakAround: true } },\n    frame: { signature: \"m\", renderInfo: { breakAround: true } },\n    parbox: { signature: \"o o o m m\", renderInfo: { breakAround: true } },\n    raisebox: { signature: \"m o o m\" },\n    marginpar: { signature: \"o m\", renderInfo: { breakAround: true } },\n    colorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    fcolorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    rotatebox: { signature: \"o m m\" },\n    scalebox: { signature: \"m o m\" },\n    reflectbox: { signature: \"m\" },\n    resizebox: { signature: \"s m m m\" },\n    // Define environments\n    newenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    newtheorem: {\n        signature: \"s m o m o\",\n        renderInfo: { breakAround: true },\n    },\n    newfont: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    alph: { signature: \"m\" },\n    Alph: { signature: \"m\" },\n    arabic: { signature: \"m\" },\n    roman: { signature: \"m\" },\n    Roman: { signature: \"m\" },\n    fnsymbol: { signature: \"m\" },\n    // Other\n    documentclass: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepackage: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    item: { signature: \"o\", renderInfo: { hangingIndent: true } },\n    value: { signature: \"m\" },\n    centering: { renderInfo: { breakAround: true } },\n    input: { signature: \"m\", renderInfo: { breakAround: true } },\n    include: { signature: \"m\", renderInfo: { breakAround: true } },\n    includeonly: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    discretionary: { signature: \"m m m\" },\n    hyphenation: { signature: \"m m m\" },\n    footnote: { signature: \"o m\", renderInfo: { inParMode: true } },\n    footnotemark: { signature: \"o\" },\n    footnotetext: { signature: \"o m\", renderInfo: { inParMode: true } },\n    caption: {\n        signature: \"o m\",\n        renderInfo: { inParMode: true, breakAround: true },\n    },\n    // Math Commands\n    sqrt: { signature: \"o m\", renderInfo: { inMathMode: true } },\n    frac: { signature: \"m m\", renderInfo: { inMathMode: true } },\n    stackrel: { signature: \"m m\" },\n    ensuremath: { signature: \"m\", renderInfo: { inMathMode: true } },\n    // Layout commands\n    abstract: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    maketitle: { renderInfo: { breakAround: true } },\n    doublespacing: { renderInfo: { breakAround: true } },\n    singlespacing: { renderInfo: { breakAround: true } },\n    author: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    date: { signature: \"m\", renderInfo: { breakAround: true } },\n    thanks: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    // amsart document class adds an optional argument\n    title: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    pagenumbering: { signature: \"m\", renderInfo: { breakAround: true } },\n    pagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    thispagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    // Colors\n    definecolor: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    pagecolor: { signature: \"o m\", renderInfo: { breakAround: true } },\n    nopagecolor: { renderInfo: { breakAround: true } },\n    multicolumn: { signature: \"m m m\" },\n    // Graphics\n    includegraphics: {\n        signature: \"s o o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    rule: { signature: \"o m m\" },\n    // Sectioning\n    part: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    chapter: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    section: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subsection: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subsubsection: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    paragraph: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subparagraph: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    appendix: { renderInfo: { breakAround: true, inParMode: true } },\n    frontmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    mainmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    backmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    // Citing and references\n    bibitem: { signature: \"o m\", renderInfo: { hangingIndent: true } },\n    cite: { signature: \"o m\" },\n    // Fonts\n    textrm: { signature: \"m\", renderInfo: { inParMode: true } },\n    textit: { signature: \"m\", renderInfo: { inParMode: true } },\n    textmd: { signature: \"m\", renderInfo: { inParMode: true } },\n    textbf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textup: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsl: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsc: { signature: \"m\", renderInfo: { inParMode: true } },\n    texttt: { signature: \"m\", renderInfo: { inParMode: true } },\n    emph: { signature: \"m\", renderInfo: { inParMode: true } },\n    textnormal: { signature: \"m\", renderInfo: { inParMode: true } },\n    uppercase: { signature: \"m\", renderInfo: { inParMode: true } },\n    mathbf: { signature: \"m\" },\n    mathsf: { signature: \"m\" },\n    mathtt: { signature: \"m\" },\n    mathit: { signature: \"m\" },\n    mathnormal: { signature: \"m\" },\n    mathcal: { signature: \"m\" },\n    mathrm: { signature: \"m\" },\n    // Other\n    setlength: { signature: \"m m\", renderInfo: { breakAround: true } },\n    ref: { signature: \"s m\" },\n    label: { signature: \"o m\" }, // cleveref changes \\label to have this signature\n    printbibliography: { renderInfo: { breakAround: true } },\n    addtocontents: { signature: \"m m\", renderInfo: { breakAround: true } },\n    addcontentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    contentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    bibliography: { signature: \"m\", renderInfo: { breakAround: true } },\n    bibliographystyle: { signature: \"m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    document: {\n        processContent: (nodes) => {\n            trim(nodes);\n            return nodes;\n        },\n    },\n    array: { signature: \"o m\", renderInfo: { alignContent: true } },\n    description: { signature: \"o\", processContent: cleanEnumerateBody },\n    enumerate: {\n        signature: \"o\",\n        processContent: cleanEnumerateBody,\n        renderInfo: { pgfkeysArgs: true },\n    },\n    itemize: { signature: \"o\", processContent: cleanEnumerateBody },\n    trivlist: { signature: \"o\", processContent: cleanEnumerateBody },\n    list: { signature: \"m m\", processContent: cleanEnumerateBody },\n    figure: { signature: \"o\" },\n    \"figure*\": { signature: \"o\" },\n    filecontents: { signature: \"o m\" },\n    \"filecontents*\": { signature: \"o m\" },\n    minipage: { signature: \"o o o m\" },\n    picture: { signature: \"r() d()\" },\n    tabbing: { renderInfo: { alignContent: true } },\n    table: { signature: \"o\" },\n    tabular: { signature: \"o m\", renderInfo: { alignContent: true } },\n    \"tabular*\": { signature: \"m o m\", renderInfo: { alignContent: true } },\n    thebibliography: {\n        signature: \"m\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"bibitem\"),\n    },\n    // Math\n    math: { renderInfo: { inMathMode: true } },\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport {\n    lastSignificantNode,\n    lastSignificantNodeIndex,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { splitOnMacro } from \"@unified-latex/unified-latex-util-split\";\nimport { trim, trimEnd } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Clean up any whitespace issues in an enumerate environment. In particular,\n *      * Remove any leading or ending whitespace\n *      * Ensure there is a par between occurrences of `\\item`\n *      * Ensure there is whitespace after each occurrence of `\\item` provided there is content there\n * `itemName` can be used to set what the \"item\" macro is called.\n *\n * This function attaches content following a `\\item` to the `\\item` macro with\n * `openMark` and `closeMark` set to empty. This allows hanging-indents to be rendered.\n */\nexport function cleanEnumerateBody(\n    ast: Ast.Node[],\n    itemName = \"item\"\n): Ast.Node[] {\n    let { segments, macros } = splitOnMacro(ast, itemName);\n    // Trim the content of each block, but make sure there is a space\n    // between each macro and the content. Since the first segment of content\n    // appears *before* any macro, don't add a space there.\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === 0) {\n            // The very first segment might be comment with leading whitespace. We don't want to trim that off\n            trimEnd(segment);\n        } else {\n            trim(segment);\n        }\n        // The very first segment comes before any `\\item` macros. It is either\n        // blank or contains comments (or is invalid LaTeX). We don't insert a space\n        // in this case.\n        if (segment.length > 0 && i > 0) {\n            segment.unshift({ type: \"whitespace\" });\n        }\n    }\n\n    let insertParbreakBefore: WeakSet<Ast.Node> = new WeakSet();\n\n    // We want a trailing indent for the `\\item` nodes. We will\n    // do this with a trick: we will add an argument to the index node\n    // with openMark=\" \" and closeMark=\"\"\n    let body: Ast.Node[] = macros.flatMap((node, i) => {\n        const segment = segments[i + 1];\n        const trailingComments = popTrailingComments(segment);\n        node.args = node.args || [];\n        node.args.push(arg(segment, { openMark: \"\", closeMark: \"\" }));\n        updateRenderInfo(node, { inParMode: true });\n\n        // The stream contains a mix of `\\item` macros and comments/parbreaks. We only\n        // want to insert parbreaks before `\\item` macros, so we record these for later.\n        if (i > 0 || segments[0]?.length > 0) {\n            insertParbreakBefore.add(node);\n        }\n\n        return [node, ...trailingComments];\n    });\n\n    // We want a parbreak between each `\\item` block and the preceding content.\n    // We've already logged the `\\item` macros in `insertParbreakBefore`.\n    body = body.flatMap((node) =>\n        insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node\n    );\n\n    body.unshift(...segments[0]);\n\n    // We have inserted parbreaks so some comments need to be told that there is a suffix parbreak\n    for (let i = 0; i < body.length - 1; i++) {\n        const node = body[i];\n        const nextNode = body[i + 1];\n        if (!match.parbreak(nextNode)) {\n            continue;\n        }\n        if (match.comment(node)) {\n            node.suffixParbreak = true;\n        }\n        // The heuristic for detecting an `item`-like node is that its last argument has no close mark.\n        // Regardless of what it is, if there is no close mark, when rendered we don't want two newlines to\n        // appear.\n        if (\n            match.macro(node) &&\n            node.args &&\n            node.args[node.args.length - 1].closeMark === \"\"\n        ) {\n            const args = node.args[node.args.length - 1].content;\n            const lastArg = args[args.length - 1];\n            if (match.comment(lastArg)) {\n                lastArg.suffixParbreak = true;\n            }\n        }\n    }\n\n    return body;\n}\n\n/**\n * Removes and returns any number of trailing comments/parbreaks from `nodes`.\n */\nfunction popTrailingComments(nodes: Ast.Node[]): Ast.Node[] {\n    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n    if (\n        lastNodeIndex === nodes.length - 1 ||\n        (lastNodeIndex == null && nodes.length === 0)\n    ) {\n        return [];\n    }\n\n    // If `nodes` has a non-zero length and we didn't find a significant node, everything is comments!\n    if (lastNodeIndex == null) {\n        lastNodeIndex = -1;\n    }\n    return nodes.splice(lastNodeIndex + 1);\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit, VisitorContext } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        context: VisitorContext\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info.context);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to delete node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n", "import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as (\n        | Ast.Node\n        | Ast.Argument\n    )[];\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
