{
  "version": 3,
  "sources": ["../../../package/systeme/index.ts", "../../../package/systeme/provides.ts", "../../../package/systeme/libs/parser.ts", "../../../package/systeme/libs/print-raw.ts", "../../../package/systeme/libs/systeme.ts", "../../../../structured-clone/index.ts"],
  "sourcesContent": ["export * from \"./provides\";\nexport * from \"./libs/parser\";\nexport * from \"./libs/print-raw\";\nexport * from \"./libs/types\";\nexport * from \"./libs/systeme\";\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    systeme: {\n        signature: \"s o o m\",\n        renderInfo: { inMathMode: true },\n    },\n    sysdelim: {\n        signature: \"m m\",\n    },\n    syseqsep: { signature: \"m\" },\n    sysalign: { signature: \"m\" },\n    syssignspace: { signature: \"m\" },\n    syseqspace: { signature: \"m\" },\n    syslineskipcoeff: { signature: \"m\" },\n    syseqivsign: { signature: \"m\" },\n    sysaddeqsign: { signature: \"m\" },\n    sysremoveeqsign: { signature: \"m\" },\n    sysextracolonsign: { signature: \"m\" },\n    syscodeextracol: { signature: \"m\" },\n    sysautonum: { signature: \"m\" },\n    syssubstitute: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as SystemeSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { SystemePegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype SystemeMatchers = {\n    at?: string;\n    equals?: string;\n    equationSeparator?: string;\n    mathOperations?: string[];\n    whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n};\n\nfunction createMatchers({\n    at = \"@\",\n    equals = \"=\",\n    equationSeparator = \",\",\n    mathOperations = [\"+\", \"-\"],\n    whitelistedVariables,\n}: SystemeMatchers = {}) {\n    let isVar: (node: Ast.Node) => boolean = (node: Ast.Node) =>\n        match.anyString(node) && !!node.content.match(/[a-zA-Z]/);\n    if (whitelistedVariables) {\n        // Unwrap all strings\n        whitelistedVariables = whitelistedVariables.map((v) =>\n            match.anyString(v) ? v.content : v\n        );\n        const macros = whitelistedVariables.filter((v) =>\n            match.anyMacro(v)\n        ) as Ast.Macro[];\n        const strings = whitelistedVariables.filter(\n            (v) => typeof v === \"string\"\n        ) as string[];\n        const macroHash = Object.fromEntries(macros.map((v) => [v.content, v]));\n        const stringHash = Object.fromEntries(strings.map((s) => [s, s]));\n        const macroMatcher = match.createMacroMatcher(macroHash);\n        isVar = (node: Ast.Node) =>\n            macroMatcher(node) ||\n            (match.anyString(node) && !!stringHash[node.content]);\n    }\n    return {\n        isSep: (node: Ast.Node) => match.string(node, equationSeparator),\n        isVar,\n        isOperation: (node: Ast.Node) =>\n            mathOperations.some((op) => match.string(node, op)),\n        isEquals: (node: Ast.Node) => match.string(node, equals),\n        isAt: (node: Ast.Node) => match.string(node, at),\n        isSubscript: (node: Ast.Node) =>\n            match.macro(node, \"_\") && node.escapeToken === \"\",\n        isWhitespace: match.whitespace,\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse(\n    ast: Ast.Node[],\n    options?: SystemeMatchers\n): SystemeSpec.Line[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return SystemePegParser.parse(\n        ast,\n        createMatchers(options || {})\n    ) as SystemeSpec.Line[];\n}\n", "import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as SystemeSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: SystemeSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"annotation\":\n            return `${latexPrintRaw(node.marker)}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"item\":\n            return `${node.op ? latexPrintRaw(node.op) : \"\"}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"equation\":\n            const left = node.left.map((n) => printRaw(n)).join(\"\");\n            const right = latexPrintRaw(node.right);\n            const equals = node.equals ? latexPrintRaw(node.equals) : \"\";\n            return `${left}${equals}${right}`;\n        case \"line\":\n            const equation = node.equation ? printRaw(node.equation) : \"\";\n            const annotation = node.annotation ? printRaw(node.annotation) : \"\";\n            const sep = node.sep ? latexPrintRaw(node.sep) : \"\";\n\n            const body = `${equation}${annotation}${sep}`;\n            if (node.trailingComment) {\n                return latexPrintRaw([body, node.trailingComment]);\n            }\n\n            return body;\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n", "import * as SystemeSpec from \"./types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { arrayJoin } from \"@unified-latex/unified-latex-util-split\";\nimport { parse } from \"./parser\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nconst AMP: Ast.String = { type: \"string\", content: \"&\" };\nconst SEP: Ast.Macro = { type: \"macro\", content: \"\\\\\" };\nconst QUAD: Ast.Macro = { type: \"macro\", content: \"quad\" };\nconst PLUS: Ast.String = { type: \"string\", content: \"+\" };\nconst COLUMN_KERN_ADJUSTMENT: Ast.Node[] = [\n    { type: \"string\", content: \"@\" },\n    {\n        type: \"group\",\n        content: [\n            { type: \"macro\", content: \"mkern\" },\n            { type: \"string\", content: \"5mu\" },\n        ],\n    },\n];\n\n/**\n * Return a map giving the sorted index of each variable in `vars`. There\n * may be duplicated variables in `vars`. The map will send duplicates to the same index.\n *\n * @param {Ast.Node[][]} vars\n * @returns\n */\nfunction sortVariables(\n    vars: Ast.Node[][],\n    whitelistedVariables?: Ast.Node[] | null\n) {\n    const varMap = new Map(vars.map((v) => [v, printRaw(v)]));\n    const varNames = Array.from(new Set(varMap.values()));\n    varNames.sort();\n    const nameToPos = whitelistedVariables\n        ? new Map(whitelistedVariables.map((v, i) => [printRaw(v), i]))\n        : new Map(varNames.map((name, i) => [name, i]));\n\n    return new Map(\n        Array.from(varMap.entries()).map(([variable, name]) => {\n            return [variable, nameToPos.get(name) ?? -1];\n        })\n    );\n}\n\n/**\n * Make an array of arrays representing the operation/content of each item in an equation\n * + the annotation. The return value is suitable to be joined with `&` for the body of an array.\n */\nfunction processLine(\n    line: SystemeSpec.Line,\n    numVars: number,\n    varOrder: Map<Ast.Node[], number>,\n    hasEquals: boolean,\n    hasAnnotation: boolean\n) {\n    const ret: Ast.Node[][] = [];\n    if (line.equation) {\n        // We need to combine all non-var items into a single expression\n        const nonVarItems = line.equation.left.filter(\n            (item) => item.variable == null\n        );\n        const varItems = line.equation.left.filter(\n            (item) => item.variable != null\n        );\n        let nonVarTerm: SystemeSpec.Item | null = null;\n        if (nonVarItems.length === 1) {\n            nonVarTerm = nonVarItems[0];\n        } else if (nonVarItems.length > 1) {\n            // We need to combine all the items. We do so by constructing a new item with the rest of the item's contents\n            // added on the back\n            nonVarTerm = {\n                ...nonVarItems[0],\n                content: nonVarItems[0].content.concat(\n                    nonVarItems.slice(1).flatMap((item) => {\n                        if (item.op) {\n                            return [item.op, ...item.content];\n                        }\n                        return [PLUS, ...item.content];\n                    })\n                ),\n            };\n        }\n\n        const allItems = nonVarTerm ? varItems.concat(nonVarTerm) : varItems;\n\n        const indexToItem = new Map(\n            allItems.map((item) => {\n                if (item.variable == null) {\n                    return [numVars - 1, item];\n                }\n                return [varOrder.get(item.variable), item];\n            })\n        );\n\n        let isFirstItem = true;\n        for (let i = 0; i < numVars; i++) {\n            const item = indexToItem.get(i);\n            if (item) {\n                if (\n                    isFirstItem &&\n                    (match.string(item.op, \"+\") || item.op == null)\n                ) {\n                    // If the first item starts with a plus or doesn't have a starting operation,\n                    // we don't use a starting symbol.\n                    ret.push([]);\n                    ret.push(item.content);\n                } else {\n                    // If we are not the first item, we always push an operation\n                    ret.push([item.op || PLUS]);\n                    ret.push(item.content);\n                }\n                isFirstItem = false;\n            } else {\n                // If there is no item for this position, we push a blank operation and content\n                ret.push([]);\n                ret.push([]);\n            }\n        }\n        // If we have an equals, we need to push its contents\n        if (hasEquals) {\n            const equalsPart = (\n                line.equation.equals ? [line.equation.equals] : []\n            ).concat(line.equation.right);\n            ret.push(equalsPart);\n        }\n    }\n    // If we have an annotation, we need to push it or a blank\n    if (hasAnnotation) {\n        ret.push(line.annotation ? line.annotation.content : []);\n    }\n\n    return ret;\n}\n\n/**\n * Add kerning information to the array specification. E.g. `crl` becomes `c@{\\mkern5mu}r@{\\mkern5mu}l`.\n * This is so the operations when typesetting a system of equations are properly spaced.\n */\nfunction arraySpecToSpacedArraySpec(spec: string, hasAnnotation?: boolean) {\n    const annotationSpec = hasAnnotation ? spec.charAt(spec.length - 1) : \"\";\n    const bodySpec = hasAnnotation ? spec.slice(0, spec.length - 1) : spec;\n\n    const bodyStrings: Ast.Node[][] = Array.from(bodySpec).map((x) => [\n        { type: \"string\", content: x },\n    ]);\n    const body = arrayJoin(bodyStrings, COLUMN_KERN_ADJUSTMENT);\n    return annotationSpec\n        ? body.concat({ type: \"string\", content: annotationSpec })\n        : body;\n}\n\n/**\n * Extract the variables from a systeme system of equations.\n */\nexport function extractVariables(nodes: SystemeSpec.Node[]): Ast.Node[][] {\n    return nodes.flatMap((node) => {\n        if (node.type === \"line\" && node.equation) {\n            return extractVariables(node.equation.left);\n        }\n        if (node.type === \"equation\") {\n            return node.left.flatMap((item) =>\n                item.variable ? [item.variable] : []\n            );\n        }\n        if (node.type === \"item\") {\n            return node.variable ? [node.variable] : [];\n        }\n        return [];\n    });\n}\n\n/**\n * Remove any whitespace from the variable list (including an explicit \" \" string).\n * As well, filter out any non-macro/non-string items.\n */\nfunction normalizeVariableWhitelist(\n    vars: (string | Ast.Node)[] | null | undefined\n) {\n    if (!vars) {\n        return null;\n    }\n    const normalized: Ast.Node[] = vars.map((v) =>\n        typeof v === \"string\" ? { type: \"string\", content: v } : v\n    );\n    const ret = normalized.filter(\n        (v) =>\n            (match.anyMacro(v) || match.anyString(v)) &&\n            !match.string(v, \" \") &&\n            !match.whitespace(v)\n    ) as (Ast.Macro | Ast.String)[];\n    return ret;\n}\n\n/**\n * Lays out the contents of a \\systeme{...} macro as an array. This function sorts the variables\n * in alphabetical order and lays out any annotations. An `\\begin{array}...\\end{array}` environment\n * is returned.\n *\n * If `properSpacing=true` then kerning information will be included in the array specification to space\n * the operators correctly. This kerning information will make the specification long (and may make it incompatible\n * with KaTeX).\n *\n * An optional whitelist of variables may be supplied. If supplied, only listed items will count as variables and\n * the order of variable appearance will be the same as the order of the whitelisted variables.\n */\nexport function systemeContentsToArray(\n    nodes: Ast.Node[],\n    options?: {\n        properSpacing?: boolean;\n        whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n    }\n) {\n    nodes = structuredClone(nodes);\n    deleteComments(nodes);\n    const { properSpacing = true, whitelistedVariables } = options || {};\n    const coercedWhitelistedVariables =\n        normalizeVariableWhitelist(whitelistedVariables);\n    const systemeAst = parse(nodes, { whitelistedVariables });\n    const vars = extractVariables(systemeAst);\n    const varOrder = sortVariables(vars, coercedWhitelistedVariables);\n    let numVars = coercedWhitelistedVariables\n        ? coercedWhitelistedVariables.length\n        : Math.max(...Array.from(varOrder.values())) + 1;\n    // If there are terms with no variable, we need a spot for them\n    if (\n        systemeAst.some((line) => {\n            if (line.equation) {\n                return line.equation.left.some((item) => item.variable == null);\n            }\n        })\n    ) {\n        numVars += 1;\n    }\n    const hasEquals = systemeAst.some(\n        (line) => line.equation && line.equation.equals\n    );\n    const hasAnnotation = systemeAst.some((line) => line.annotation);\n\n    let rows = systemeAst.map((line) =>\n        processLine(line, numVars, varOrder, hasEquals, hasAnnotation)\n    );\n    // If we have no leading `-` signs (e.g., only leading `+` or bank signs)\n    // We don't need space for the first operation to be stored\n    const noLeadingOperation = rows.every((row) => row[0].length === 0);\n\n    // Every item in an equation has a centered operation and a right-aligned variable part.\n    let arraySignature = Array.from({ length: numVars }, () => \"cr\").join(\"\");\n    if (noLeadingOperation) {\n        // We might not have a leading operation on the first item(s)\n        arraySignature = arraySignature.slice(1);\n        rows = rows.map((row) => row.slice(1));\n    }\n    if (hasEquals) {\n        // The part after the equals is left-aligned\n        arraySignature += \"l\";\n    }\n    if (hasAnnotation) {\n        // The annotation is left-aligned\n        arraySignature += \"l\";\n        // We also manually insert space in front of any annotation\n        rows = rows.map((row) => {\n            if (row[row.length - 1].length === 0) {\n                return row;\n            }\n            return [\n                ...row.slice(0, row.length - 1),\n                [QUAD, { type: \"whitespace\" }, ...row[row.length - 1]],\n            ];\n        });\n    }\n\n    // By default, the array signature will put lots of space between items.\n    // We can correct for that manually.\n    const arraySignatureWithSpacing: Ast.Node[] = properSpacing\n        ? arraySpecToSpacedArraySpec(arraySignature, hasAnnotation)\n        : [{ type: \"string\", content: arraySignature }];\n\n    const bodyRows = rows.map((row) => arrayJoin(row, AMP));\n    const body = arrayJoin(bodyRows, SEP);\n\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: \"array\",\n        args: [\n            {\n                type: \"argument\",\n                openMark: \"{\",\n                closeMark: \"}\",\n                content: arraySignatureWithSpacing,\n            },\n        ],\n        content: body,\n    };\n\n    return ret;\n}\n\n/**\n * Find any systeme definitions, e.g. `\\sysdelim{.}{.}`, and attach their information\n * to the renderInfo of of the systeme macros.\n *\n */\nexport function attachSystemeSettingsAsRenderInfo(ast: Ast.Ast) {\n    const systemeMatcher = match.createMacroMatcher([\"systeme\", \"sysdelim\"]);\n\n    visit(\n        ast,\n        (nodes, info) => {\n            if (!info.context.inMathMode || !nodes.some(systemeMatcher)) {\n                return;\n            }\n            // Find the positions of the systeme and sysdelim macros\n            const systemeLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"systeme\") ? i : []\n            );\n            const sysdelimLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"sysdelim\") ? i : []\n            );\n\n            if (\n                systemeLocations.length === 0 ||\n                sysdelimLocations.length === 0\n            ) {\n                return;\n            }\n\n            for (const i of systemeLocations) {\n                // Find any sysdelim macros that occur before\n                const lastSysdelim = Math.max(\n                    ...sysdelimLocations.filter((loc) => loc < i)\n                );\n                if (lastSysdelim >= 0) {\n                    const node = nodes[i];\n                    const sysdelimMacro = nodes[lastSysdelim];\n                    if (!match.anyMacro(sysdelimMacro)) {\n                        throw new Error(\n                            `Expecting sysdelim macro but found \"${printRaw(\n                                sysdelimMacro\n                            )}\"`\n                        );\n                    }\n                    const args = getArgsContent(sysdelimMacro);\n                    updateRenderInfo(node, { sysdelims: args });\n                }\n            }\n        },\n        {\n            test: Array.isArray,\n            includeArrays: true,\n        }\n    );\n}\n", "// @ts-nocheck\n\n// globalThis polyfill from https://mathiasbynens.be/notes/globalthis\n(function () {\n    if (typeof globalThis === \"object\") return;\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n        get: function () {\n            return this;\n        },\n        configurable: true, // This makes it possible to `delete` the getter later.\n    });\n    __magic__.globalThis = __magic__; // lolwat\n    delete Object.prototype.__magic__;\n})();\n\nconst clone =\n    typeof globalThis.structuredClone === \"function\"\n        ? globalThis.structuredClone\n        : (obj: any) => JSON.parse(JSON.stringify(obj));\n\n/**\n * Wrapper around the built-in structured clone. Uses `JSON.parse(JSON.stringify(...))`\n * as a fallback.\n */\nexport function structuredClone<T>(obj: T): T {\n    return clone(obj);\n}\n"],
  "mappings": "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",
  "names": []
}
