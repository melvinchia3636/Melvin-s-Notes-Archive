{
  "version": 3,
  "sources": ["../package/cleveref/provides.ts", "../utils/enumerate.ts", "../../unified-latex-util-replace/libs/replace-node.ts", "../../unified-latex-util-replace/libs/unified-latex-streaming-command.ts", "../../unified-latex-util-replace/libs/replace-streaming-command.ts", "../../unified-latex-util-replace/libs/utils/significant-node.ts", "../../unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts", "../../unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts", "../../unified-latex-util-replace/libs/utils/wrap-significant-content.ts", "../../unified-latex-util-replace/libs/replace-node-during-visit.ts", "../package/exam/provides.ts", "../package/geometry/provides.ts", "../package/hyperref/provides.ts", "../package/latex2e/provides.ts", "../package/makeidx/provides.ts", "../package/mathtools/provides.ts", "../package/nicematrix/provides.ts", "../package/systeme/provides.ts", "../package/systeme/libs/parser.ts", "../package/systeme/libs/print-raw.ts", "../package/systeme/libs/systeme.ts", "../../structured-clone/index.ts", "../package/tikz/provides.ts", "../package/xcolor/provides.ts", "../package/xcolor/libs/xcolor.ts", "../package/xcolor/libs/predefined-colors.ts", "../package/xcolor/libs/parser.ts", "../package/xcolor/libs/xcolor-macro-to-hex.ts", "../package/xcolor/libs/color-to-textcolor-macro.ts", "../package/xparse/provides.ts", "../index.ts"],
  "sourcesContent": ["import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    cref: { signature: \"s m\" },\n    Cref: { signature: \"s m\" },\n    crefrange: { signature: \"s m m\" },\n    Crefrange: { signature: \"s m m\" },\n    cpageref: { signature: \"s m\" },\n    Cpageref: { signature: \"s m\" },\n    ref: { signature: \"m\" },\n    pageref: { signature: \"m\" },\n    namecref: { signature: \"m\" },\n    nameCref: { signature: \"m\" },\n    lcnamecref: { signature: \"m\" },\n    namecrefs: { signature: \"m\" },\n    nameCrefs: { signature: \"m\" },\n    lcnamecrefs: { signature: \"m\" },\n    labelcref: { signature: \"m\" },\n    labelcpageref: { signature: \"m\" },\n    crefalias: { signature: \"m m\" },\n    crefname: { signature: \"m m m\" },\n    // XXX there are many more obscure commands to add here\n    // https://ctan.org/pkg/cleveref\n    crefdefaultlabelformat: { signature: \"m\" },\n    crefrangeconjunction: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport {\n    lastSignificantNode,\n    lastSignificantNodeIndex,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { splitOnMacro } from \"@unified-latex/unified-latex-util-split\";\nimport { trim, trimEnd } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Clean up any whitespace issues in an enumerate environment. In particular,\n *      * Remove any leading or ending whitespace\n *      * Ensure there is a par between occurrences of `\\item`\n *      * Ensure there is whitespace after each occurrence of `\\item` provided there is content there\n * `itemName` can be used to set what the \"item\" macro is called.\n *\n * This function attaches content following a `\\item` to the `\\item` macro with\n * `openMark` and `closeMark` set to empty. This allows hanging-indents to be rendered.\n */\nexport function cleanEnumerateBody(\n    ast: Ast.Node[],\n    itemName = \"item\"\n): Ast.Node[] {\n    let { segments, macros } = splitOnMacro(ast, itemName);\n    // Trim the content of each block, but make sure there is a space\n    // between each macro and the content. Since the first segment of content\n    // appears *before* any macro, don't add a space there.\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === 0) {\n            // The very first segment might be comment with leading whitespace. We don't want to trim that off\n            trimEnd(segment);\n        } else {\n            trim(segment);\n        }\n        // The very first segment comes before any `\\item` macros. It is either\n        // blank or contains comments (or is invalid LaTeX). We don't insert a space\n        // in this case.\n        if (segment.length > 0 && i > 0) {\n            segment.unshift({ type: \"whitespace\" });\n        }\n    }\n\n    let insertParbreakBefore: WeakSet<Ast.Node> = new WeakSet();\n\n    // We want a trailing indent for the `\\item` nodes. We will\n    // do this with a trick: we will add an argument to the index node\n    // with openMark=\" \" and closeMark=\"\"\n    let body: Ast.Node[] = macros.flatMap((node, i) => {\n        const segment = segments[i + 1];\n        const trailingComments = popTrailingComments(segment);\n        node.args = node.args || [];\n        node.args.push(arg(segment, { openMark: \"\", closeMark: \"\" }));\n        updateRenderInfo(node, { inParMode: true });\n\n        // The stream contains a mix of `\\item` macros and comments/parbreaks. We only\n        // want to insert parbreaks before `\\item` macros, so we record these for later.\n        if (i > 0 || segments[0]?.length > 0) {\n            insertParbreakBefore.add(node);\n        }\n\n        return [node, ...trailingComments];\n    });\n\n    // We want a parbreak between each `\\item` block and the preceding content.\n    // We've already logged the `\\item` macros in `insertParbreakBefore`.\n    body = body.flatMap((node) =>\n        insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node\n    );\n\n    body.unshift(...segments[0]);\n\n    // We have inserted parbreaks so some comments need to be told that there is a suffix parbreak\n    for (let i = 0; i < body.length - 1; i++) {\n        const node = body[i];\n        const nextNode = body[i + 1];\n        if (!match.parbreak(nextNode)) {\n            continue;\n        }\n        if (match.comment(node)) {\n            node.suffixParbreak = true;\n        }\n        // The heuristic for detecting an `item`-like node is that its last argument has no close mark.\n        // Regardless of what it is, if there is no close mark, when rendered we don't want two newlines to\n        // appear.\n        if (\n            match.macro(node) &&\n            node.args &&\n            node.args[node.args.length - 1].closeMark === \"\"\n        ) {\n            const args = node.args[node.args.length - 1].content;\n            const lastArg = args[args.length - 1];\n            if (match.comment(lastArg)) {\n                lastArg.suffixParbreak = true;\n            }\n        }\n    }\n\n    return body;\n}\n\n/**\n * Removes and returns any number of trailing comments/parbreaks from `nodes`.\n */\nfunction popTrailingComments(nodes: Ast.Node[]): Ast.Node[] {\n    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n    if (\n        lastNodeIndex === nodes.length - 1 ||\n        (lastNodeIndex == null && nodes.length === 0)\n    ) {\n        return [];\n    }\n\n    // If `nodes` has a non-zero length and we didn't find a significant node, everything is comments!\n    if (lastNodeIndex == null) {\n        lastNodeIndex = -1;\n    }\n    return nodes.splice(lastNodeIndex + 1);\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit, VisitorContext } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        context: VisitorContext\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info.context);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to delete node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n", "import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as (\n        | Ast.Node\n        | Ast.Argument\n    )[];\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    answerline: { signature: \"o\" },\n    fillin: { signature: \"o o\" },\n    fullwidth: { signature: \"m\" },\n    fillwidthlines: { signature: \"m\" },\n    fillwidthdottedlines: { signature: \"m\" },\n    fillwidthgrid: { signature: \"m\" },\n    makeemptybox: { signature: \"m\" },\n    CorrectChoiceEmphasis: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    SolutionEmphasis: { signature: \"m\", renderInfo: { breakAround: true } },\n    uplevel: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkboxchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkedchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    marginpointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    extrawidth: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    bonuspointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    totalformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    qformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    titledquestion: { signature: \"m o\", renderInfo: { breakAround: true } },\n    pointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n    bonuspointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    choices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    checkboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparchoices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparcheckboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    parts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"part\"),\n    },\n    subparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subpart\"),\n    },\n    subsubparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subsubpart\"),\n    },\n    questions: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"question\"),\n    },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    geometry: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    hypersetup: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    href: { signature: \"o m m\" },\n    url: { signature: \"m\" },\n    nolinkurl: { signature: \"m\" },\n    hyperbaseurl: { signature: \"m\" },\n    hyperimage: { signature: \"m m\" },\n    hyperdef: { signature: \"m m m\" },\n    hyperref: { signature: \"o m\" },\n    hyperlink: { signature: \"m m\" },\n    hypertarget: { signature: \"m m\" },\n    autoref: { signature: \"s m\" },\n    pageref: { signature: \"s m\" },\n    autopageref: { signature: \"s m\" },\n    pdfstringdef: { signature: \"m m\" },\n    pdfbookmark: { signature: \"o m m\" },\n    currentpdfbookmark: { signature: \"m m\" },\n    subpdfbookmark: { signature: \"m m\" },\n    belowpdfbookmark: { signature: \"m m\" },\n    texorpdfstring: { signature: \"m m\" },\n    thispdfpagelabel: { signature: \"m\" },\n    hypercalcbp: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    // Special\n    \"\\\\\": { signature: \"!s o\" },\n    _: { signature: \"m\", escapeToken: \"\" },\n    \"^\": { signature: \"m\", escapeToken: \"\" },\n    // \\newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands\n    // List can be found in latex2e.pdf \"An unofficial reference manual\"\n    newcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    renewcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    providecommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    newcounter: {\n        signature: \"m o\",\n        renderInfo: { breakAround: true },\n    },\n    usecounter: {\n        signature: \"m\",\n    },\n    setcounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    addtocounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    stepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    refstepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    // Lengths\n    newlength: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    addtolength: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settodepth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settoheight: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settowidth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Spaces\n    stretch: { signature: \"m\" },\n    hspace: { signature: \"s m\" },\n    vspace: { signature: \"s m\", renderInfo: { breakAround: true } },\n    vfill: { renderInfo: { breakAround: true } },\n    indent: { renderInfo: { breakAround: true } },\n    phantom: { signature: \"m\" },\n    vphantom: { signature: \"m\" },\n    hphantom: { signature: \"m\" },\n    noindent: { renderInfo: { breakAround: true } },\n    smallskip: { renderInfo: { breakAround: true } },\n    medskip: { renderInfo: { breakAround: true } },\n    bigskip: { renderInfo: { breakAround: true } },\n    smallbreak: { renderInfo: { breakAround: true } },\n    medbreak: { renderInfo: { breakAround: true } },\n    bigbreak: { renderInfo: { breakAround: true } },\n    newline: { renderInfo: { breakAround: true } },\n    linebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nolinebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    clearpage: { renderInfo: { breakAround: true } },\n    cleardoublepage: { renderInfo: { breakAround: true } },\n    newpage: { renderInfo: { breakAround: true } },\n    enlargethispage: { signature: \"s\", renderInfo: { breakAround: true } },\n    pagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nopagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    // Boxes\n    newsavebox: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    sbox: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    savebox: {\n        signature: \"m o o m\",\n        renderInfo: { breakAround: true },\n    },\n    mbox: { signature: \"m\" },\n    makebox: { signature: \"d() o o m\", renderInfo: { breakAround: true } },\n    fbox: { signature: \"m\" },\n    framebox: { signature: \"o o m\", renderInfo: { breakAround: true } },\n    frame: { signature: \"m\", renderInfo: { breakAround: true } },\n    parbox: { signature: \"o o o m m\", renderInfo: { breakAround: true } },\n    raisebox: { signature: \"m o o m\" },\n    marginpar: { signature: \"o m\", renderInfo: { breakAround: true } },\n    colorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    fcolorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    rotatebox: { signature: \"o m m\" },\n    scalebox: { signature: \"m o m\" },\n    reflectbox: { signature: \"m\" },\n    resizebox: { signature: \"s m m m\" },\n    // Define environments\n    newenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    newtheorem: {\n        signature: \"s m o m o\",\n        renderInfo: { breakAround: true },\n    },\n    newfont: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    alph: { signature: \"m\" },\n    Alph: { signature: \"m\" },\n    arabic: { signature: \"m\" },\n    roman: { signature: \"m\" },\n    Roman: { signature: \"m\" },\n    fnsymbol: { signature: \"m\" },\n    // Other\n    documentclass: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepackage: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    item: { signature: \"o\", renderInfo: { hangingIndent: true } },\n    value: { signature: \"m\" },\n    centering: { renderInfo: { breakAround: true } },\n    input: { signature: \"m\", renderInfo: { breakAround: true } },\n    include: { signature: \"m\", renderInfo: { breakAround: true } },\n    includeonly: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    discretionary: { signature: \"m m m\" },\n    hyphenation: { signature: \"m m m\" },\n    footnote: { signature: \"o m\", renderInfo: { inParMode: true } },\n    footnotemark: { signature: \"o\" },\n    footnotetext: { signature: \"o m\", renderInfo: { inParMode: true } },\n    caption: {\n        signature: \"o m\",\n        renderInfo: { inParMode: true, breakAround: true },\n    },\n    // Math Commands\n    sqrt: { signature: \"o m\", renderInfo: { inMathMode: true } },\n    frac: { signature: \"m m\", renderInfo: { inMathMode: true } },\n    stackrel: { signature: \"m m\" },\n    ensuremath: { signature: \"m\", renderInfo: { inMathMode: true } },\n    // Layout commands\n    abstract: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    maketitle: { renderInfo: { breakAround: true } },\n    doublespacing: { renderInfo: { breakAround: true } },\n    singlespacing: { renderInfo: { breakAround: true } },\n    author: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    date: { signature: \"m\", renderInfo: { breakAround: true } },\n    thanks: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    // amsart document class adds an optional argument\n    title: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    pagenumbering: { signature: \"m\", renderInfo: { breakAround: true } },\n    pagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    thispagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    // Colors\n    definecolor: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    pagecolor: { signature: \"o m\", renderInfo: { breakAround: true } },\n    nopagecolor: { renderInfo: { breakAround: true } },\n    multicolumn: { signature: \"m m m\" },\n    // Graphics\n    includegraphics: {\n        signature: \"s o o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    rule: { signature: \"o m m\" },\n    // Sectioning\n    part: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    chapter: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    section: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subsection: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subsubsection: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    paragraph: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    subparagraph: {\n        signature: \"s o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    appendix: { renderInfo: { breakAround: true, inParMode: true } },\n    frontmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    mainmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    backmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    // Citing and references\n    bibitem: { signature: \"o m\", renderInfo: { hangingIndent: true } },\n    cite: { signature: \"o m\" },\n    // Fonts\n    textrm: { signature: \"m\", renderInfo: { inParMode: true } },\n    textit: { signature: \"m\", renderInfo: { inParMode: true } },\n    textmd: { signature: \"m\", renderInfo: { inParMode: true } },\n    textbf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textup: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsl: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsc: { signature: \"m\", renderInfo: { inParMode: true } },\n    texttt: { signature: \"m\", renderInfo: { inParMode: true } },\n    emph: { signature: \"m\", renderInfo: { inParMode: true } },\n    textnormal: { signature: \"m\", renderInfo: { inParMode: true } },\n    uppercase: { signature: \"m\", renderInfo: { inParMode: true } },\n    mathbf: { signature: \"m\" },\n    mathsf: { signature: \"m\" },\n    mathtt: { signature: \"m\" },\n    mathit: { signature: \"m\" },\n    mathnormal: { signature: \"m\" },\n    mathcal: { signature: \"m\" },\n    mathrm: { signature: \"m\" },\n    // Other\n    setlength: { signature: \"m m\", renderInfo: { breakAround: true } },\n    ref: { signature: \"s m\" },\n    label: { signature: \"o m\" }, // cleveref changes \\label to have this signature\n    printbibliography: { renderInfo: { breakAround: true } },\n    addtocontents: { signature: \"m m\", renderInfo: { breakAround: true } },\n    addcontentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    contentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    bibliography: { signature: \"m\", renderInfo: { breakAround: true } },\n    bibliographystyle: { signature: \"m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    document: {\n        processContent: (nodes) => {\n            trim(nodes);\n            return nodes;\n        },\n    },\n    array: { signature: \"o m\", renderInfo: { alignContent: true } },\n    description: { signature: \"o\", processContent: cleanEnumerateBody },\n    enumerate: {\n        signature: \"o\",\n        processContent: cleanEnumerateBody,\n        renderInfo: { pgfkeysArgs: true },\n    },\n    itemize: { signature: \"o\", processContent: cleanEnumerateBody },\n    trivlist: { signature: \"o\", processContent: cleanEnumerateBody },\n    list: { signature: \"m m\", processContent: cleanEnumerateBody },\n    figure: { signature: \"o\" },\n    \"figure*\": { signature: \"o\" },\n    filecontents: { signature: \"o m\" },\n    \"filecontents*\": { signature: \"o m\" },\n    minipage: { signature: \"o o o m\" },\n    picture: { signature: \"r() d()\" },\n    tabbing: { renderInfo: { alignContent: true } },\n    table: { signature: \"o\" },\n    tabular: { signature: \"o m\", renderInfo: { alignContent: true } },\n    \"tabular*\": { signature: \"m o m\", renderInfo: { alignContent: true } },\n    thebibliography: {\n        signature: \"m\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"bibitem\"),\n    },\n    // Math\n    math: { renderInfo: { inMathMode: true } },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    see: { signature: \"m m\" },\n    seealso: { signature: \"m m\" },\n    seename: { signature: \"m\" },\n    alsoname: { signature: \"m\" },\n    index: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    mathtoolsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    mathllap: {\n        signature: \"o m\",\n    },\n    mathrlap: {\n        signature: \"o m\",\n    },\n    mathclap: {\n        signature: \"o m\",\n    },\n    clap: {\n        signature: \"m\",\n    },\n    mathmbox: {\n        signature: \"m\",\n    },\n    mathmakebox: {\n        signature: \"o o m\",\n    },\n    cramped: {\n        signature: \"o m\",\n    },\n    crampedllap: {\n        signature: \"o m\",\n    },\n    crampedrlap: {\n        signature: \"o m\",\n    },\n    crampedclap: {\n        signature: \"o m\",\n    },\n    crampedsubstack: {\n        signature: \"o m\",\n    },\n    smashoperator: {\n        signature: \"o m\",\n    },\n    newtagform: {\n        signature: \"m o m m\",\n    },\n    renewtagform: {\n        signature: \"m o m m\",\n    },\n    usetagform: {\n        signature: \"m\",\n    },\n    xleftrightarrow: { signature: \"o m\" },\n    xLeftarrow: { signature: \"o m\" },\n    xhookleftarrow: { signature: \"o m\" },\n    xmapsto: { signature: \"o m\" },\n    xRightarrow: { signature: \"o m\" },\n    xLeftrightarrow: { signature: \"o m\" },\n    xhookrightarrow: { signature: \"o m\" },\n    underbracket: { signature: \"o o m\" },\n    overbracket: { signature: \"o o m\" },\n    underbrace: { signature: \"m\" },\n    overbrace: { signature: \"m\" },\n    shoveleft: { signature: \"o m\" },\n    shoveright: { signature: \"o m\" },\n    ArrowBetweenLines: { signature: \"s o\" },\n    vdotswithin: { signature: \"m\" },\n    shortdotswithin: { signature: \"s m\" },\n    DeclarePairedDelimiter: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterX: {\n        signature: \"m o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterXPP: {\n        signature: \"m o m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    prescript: { signature: \"m m m\" },\n    DeclareMathSizes: { signature: \"m m m m\" },\n    newgathered: { signature: \"m m m m\" },\n    renewgathered: { signature: \"m m m m\" },\n    splitfrac: { signature: \"m m\" },\n    splitdfrac: { signature: \"m m\" },\n    xmathstrut: { signature: \"o m\" },\n    // amsthm\n    newtheorem: { signature: \"s m o m o\", renderInfo: { breakAround: true } },\n    theoremstyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    newtheoremstyle: {\n        signature: \"m m m m m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    // amsmath\n    text: { signature: \"m\", renderInfo: { inMathMode: false } },\n    // amsfonts\n    mathbb: { signature: \"m\" },\n    mathscr: { signature: \"m\" },\n    mathfrak: { signature: \"m\" },\n    frak: { signature: \"m\" },\n    Bdd: { signature: \"m\" },\n    bold: { signature: \"m\" },\n    // amsopn\n    operatorname: { signature: \"s m\" },\n    DeclareMathOperator: {\n        signature: \"s m m\",\n        renderInfo: { breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    crampedsubarray: {\n        signature: \"m\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    matrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"matrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"pmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"smallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"psmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    multilined: { signature: \"o o\", renderInfo: { inMathMode: true } },\n    cases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"cases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    dcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"dcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    rcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"rcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    drcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"drcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    spreadlines: { signature: \"m\", renderInfo: { inMathMode: true } },\n    lgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    rgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    // amsmath\n    \"align*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    align: { renderInfo: { inMathMode: true, alignContent: true } },\n    aligned: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"alignat*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    alignat: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"equation*\": { renderInfo: { inMathMode: true } },\n    equation: { renderInfo: { inMathMode: true } },\n    \"gather*\": { renderInfo: { inMathMode: true } },\n    gather: { renderInfo: { inMathMode: true } },\n    \"multline*\": { renderInfo: { inMathMode: true } },\n    multline: { renderInfo: { inMathMode: true } },\n    \"flalign*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    flalign: { renderInfo: { inMathMode: true, alignContent: true } },\n    split: { renderInfo: { inMathMode: true } },\n    // Math environments\n    displaymath: { renderInfo: { inMathMode: true } },\n    // Typical amsthm environments\n    theorem: { signature: \"o\" },\n    lemma: { signature: \"o\" },\n    definition: { signature: \"o\" },\n    proposition: { signature: \"o\" },\n    corollary: { signature: \"o\" },\n    remark: { signature: \"!o\" },\n    example: { signature: \"!o\" },\n    proof: { signature: \"o\" },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NiceMatrixOptions: {\n        signature: \"m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    NiceTabular: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrixBlock: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArrayWithDelims: {\n        signature: \"m m o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    systeme: {\n        signature: \"s o o m\",\n        renderInfo: { inMathMode: true },\n    },\n    sysdelim: {\n        signature: \"m m\",\n    },\n    syseqsep: { signature: \"m\" },\n    sysalign: { signature: \"m\" },\n    syssignspace: { signature: \"m\" },\n    syseqspace: { signature: \"m\" },\n    syslineskipcoeff: { signature: \"m\" },\n    syseqivsign: { signature: \"m\" },\n    sysaddeqsign: { signature: \"m\" },\n    sysremoveeqsign: { signature: \"m\" },\n    sysextracolonsign: { signature: \"m\" },\n    syscodeextracol: { signature: \"m\" },\n    sysautonum: { signature: \"m\" },\n    syssubstitute: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as SystemeSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { SystemePegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype SystemeMatchers = {\n    at?: string;\n    equals?: string;\n    equationSeparator?: string;\n    mathOperations?: string[];\n    whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n};\n\nfunction createMatchers({\n    at = \"@\",\n    equals = \"=\",\n    equationSeparator = \",\",\n    mathOperations = [\"+\", \"-\"],\n    whitelistedVariables,\n}: SystemeMatchers = {}) {\n    let isVar: (node: Ast.Node) => boolean = (node: Ast.Node) =>\n        match.anyString(node) && !!node.content.match(/[a-zA-Z]/);\n    if (whitelistedVariables) {\n        // Unwrap all strings\n        whitelistedVariables = whitelistedVariables.map((v) =>\n            match.anyString(v) ? v.content : v\n        );\n        const macros = whitelistedVariables.filter((v) =>\n            match.anyMacro(v)\n        ) as Ast.Macro[];\n        const strings = whitelistedVariables.filter(\n            (v) => typeof v === \"string\"\n        ) as string[];\n        const macroHash = Object.fromEntries(macros.map((v) => [v.content, v]));\n        const stringHash = Object.fromEntries(strings.map((s) => [s, s]));\n        const macroMatcher = match.createMacroMatcher(macroHash);\n        isVar = (node: Ast.Node) =>\n            macroMatcher(node) ||\n            (match.anyString(node) && !!stringHash[node.content]);\n    }\n    return {\n        isSep: (node: Ast.Node) => match.string(node, equationSeparator),\n        isVar,\n        isOperation: (node: Ast.Node) =>\n            mathOperations.some((op) => match.string(node, op)),\n        isEquals: (node: Ast.Node) => match.string(node, equals),\n        isAt: (node: Ast.Node) => match.string(node, at),\n        isSubscript: (node: Ast.Node) =>\n            match.macro(node, \"_\") && node.escapeToken === \"\",\n        isWhitespace: match.whitespace,\n        isSameLineComment: (node: Ast.Node) =>\n            match.comment(node) && node.sameline,\n        isOwnLineComment: (node: Ast.Node) =>\n            match.comment(node) && !node.sameline,\n    };\n}\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse(\n    ast: Ast.Node[],\n    options?: SystemeMatchers\n): SystemeSpec.Line[] {\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return SystemePegParser.parse(\n        ast,\n        createMatchers(options || {})\n    ) as SystemeSpec.Line[];\n}\n", "import { printRaw as latexPrintRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as SystemeSpec from \"./types\";\n\n/**\n * Print an `systeme` argument specification AST to a string.\n */\nexport function printRaw(node: SystemeSpec.Ast, root = false): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    switch (node.type) {\n        case \"annotation\":\n            return `${latexPrintRaw(node.marker)}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"item\":\n            return `${node.op ? latexPrintRaw(node.op) : \"\"}${latexPrintRaw(\n                node.content\n            )}`;\n        case \"equation\":\n            const left = node.left.map((n) => printRaw(n)).join(\"\");\n            const right = latexPrintRaw(node.right);\n            const equals = node.equals ? latexPrintRaw(node.equals) : \"\";\n            return `${left}${equals}${right}`;\n        case \"line\":\n            const equation = node.equation ? printRaw(node.equation) : \"\";\n            const annotation = node.annotation ? printRaw(node.annotation) : \"\";\n            const sep = node.sep ? latexPrintRaw(node.sep) : \"\";\n\n            const body = `${equation}${annotation}${sep}`;\n            if (node.trailingComment) {\n                return latexPrintRaw([body, node.trailingComment]);\n            }\n\n            return body;\n\n        default:\n            console.warn(\n                `Unknown node type \"${(node as any).type}\" for node`,\n                node\n            );\n            return \"\";\n    }\n}\n", "import * as SystemeSpec from \"./types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { arrayJoin } from \"@unified-latex/unified-latex-util-split\";\nimport { parse } from \"./parser\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nconst AMP: Ast.String = { type: \"string\", content: \"&\" };\nconst SEP: Ast.Macro = { type: \"macro\", content: \"\\\\\" };\nconst QUAD: Ast.Macro = { type: \"macro\", content: \"quad\" };\nconst PLUS: Ast.String = { type: \"string\", content: \"+\" };\nconst COLUMN_KERN_ADJUSTMENT: Ast.Node[] = [\n    { type: \"string\", content: \"@\" },\n    {\n        type: \"group\",\n        content: [\n            { type: \"macro\", content: \"mkern\" },\n            { type: \"string\", content: \"5mu\" },\n        ],\n    },\n];\n\n/**\n * Return a map giving the sorted index of each variable in `vars`. There\n * may be duplicated variables in `vars`. The map will send duplicates to the same index.\n *\n * @param {Ast.Node[][]} vars\n * @returns\n */\nfunction sortVariables(\n    vars: Ast.Node[][],\n    whitelistedVariables?: Ast.Node[] | null\n) {\n    const varMap = new Map(vars.map((v) => [v, printRaw(v)]));\n    const varNames = Array.from(new Set(varMap.values()));\n    varNames.sort();\n    const nameToPos = whitelistedVariables\n        ? new Map(whitelistedVariables.map((v, i) => [printRaw(v), i]))\n        : new Map(varNames.map((name, i) => [name, i]));\n\n    return new Map(\n        Array.from(varMap.entries()).map(([variable, name]) => {\n            return [variable, nameToPos.get(name) ?? -1];\n        })\n    );\n}\n\n/**\n * Make an array of arrays representing the operation/content of each item in an equation\n * + the annotation. The return value is suitable to be joined with `&` for the body of an array.\n */\nfunction processLine(\n    line: SystemeSpec.Line,\n    numVars: number,\n    varOrder: Map<Ast.Node[], number>,\n    hasEquals: boolean,\n    hasAnnotation: boolean\n) {\n    const ret: Ast.Node[][] = [];\n    if (line.equation) {\n        // We need to combine all non-var items into a single expression\n        const nonVarItems = line.equation.left.filter(\n            (item) => item.variable == null\n        );\n        const varItems = line.equation.left.filter(\n            (item) => item.variable != null\n        );\n        let nonVarTerm: SystemeSpec.Item | null = null;\n        if (nonVarItems.length === 1) {\n            nonVarTerm = nonVarItems[0];\n        } else if (nonVarItems.length > 1) {\n            // We need to combine all the items. We do so by constructing a new item with the rest of the item's contents\n            // added on the back\n            nonVarTerm = {\n                ...nonVarItems[0],\n                content: nonVarItems[0].content.concat(\n                    nonVarItems.slice(1).flatMap((item) => {\n                        if (item.op) {\n                            return [item.op, ...item.content];\n                        }\n                        return [PLUS, ...item.content];\n                    })\n                ),\n            };\n        }\n\n        const allItems = nonVarTerm ? varItems.concat(nonVarTerm) : varItems;\n\n        const indexToItem = new Map(\n            allItems.map((item) => {\n                if (item.variable == null) {\n                    return [numVars - 1, item];\n                }\n                return [varOrder.get(item.variable), item];\n            })\n        );\n\n        let isFirstItem = true;\n        for (let i = 0; i < numVars; i++) {\n            const item = indexToItem.get(i);\n            if (item) {\n                if (\n                    isFirstItem &&\n                    (match.string(item.op, \"+\") || item.op == null)\n                ) {\n                    // If the first item starts with a plus or doesn't have a starting operation,\n                    // we don't use a starting symbol.\n                    ret.push([]);\n                    ret.push(item.content);\n                } else {\n                    // If we are not the first item, we always push an operation\n                    ret.push([item.op || PLUS]);\n                    ret.push(item.content);\n                }\n                isFirstItem = false;\n            } else {\n                // If there is no item for this position, we push a blank operation and content\n                ret.push([]);\n                ret.push([]);\n            }\n        }\n        // If we have an equals, we need to push its contents\n        if (hasEquals) {\n            const equalsPart = (\n                line.equation.equals ? [line.equation.equals] : []\n            ).concat(line.equation.right);\n            ret.push(equalsPart);\n        }\n    }\n    // If we have an annotation, we need to push it or a blank\n    if (hasAnnotation) {\n        ret.push(line.annotation ? line.annotation.content : []);\n    }\n\n    return ret;\n}\n\n/**\n * Add kerning information to the array specification. E.g. `crl` becomes `c@{\\mkern5mu}r@{\\mkern5mu}l`.\n * This is so the operations when typesetting a system of equations are properly spaced.\n */\nfunction arraySpecToSpacedArraySpec(spec: string, hasAnnotation?: boolean) {\n    const annotationSpec = hasAnnotation ? spec.charAt(spec.length - 1) : \"\";\n    const bodySpec = hasAnnotation ? spec.slice(0, spec.length - 1) : spec;\n\n    const bodyStrings: Ast.Node[][] = Array.from(bodySpec).map((x) => [\n        { type: \"string\", content: x },\n    ]);\n    const body = arrayJoin(bodyStrings, COLUMN_KERN_ADJUSTMENT);\n    return annotationSpec\n        ? body.concat({ type: \"string\", content: annotationSpec })\n        : body;\n}\n\n/**\n * Extract the variables from a systeme system of equations.\n */\nexport function extractVariables(nodes: SystemeSpec.Node[]): Ast.Node[][] {\n    return nodes.flatMap((node) => {\n        if (node.type === \"line\" && node.equation) {\n            return extractVariables(node.equation.left);\n        }\n        if (node.type === \"equation\") {\n            return node.left.flatMap((item) =>\n                item.variable ? [item.variable] : []\n            );\n        }\n        if (node.type === \"item\") {\n            return node.variable ? [node.variable] : [];\n        }\n        return [];\n    });\n}\n\n/**\n * Remove any whitespace from the variable list (including an explicit \" \" string).\n * As well, filter out any non-macro/non-string items.\n */\nfunction normalizeVariableWhitelist(\n    vars: (string | Ast.Node)[] | null | undefined\n) {\n    if (!vars) {\n        return null;\n    }\n    const normalized: Ast.Node[] = vars.map((v) =>\n        typeof v === \"string\" ? { type: \"string\", content: v } : v\n    );\n    const ret = normalized.filter(\n        (v) =>\n            (match.anyMacro(v) || match.anyString(v)) &&\n            !match.string(v, \" \") &&\n            !match.whitespace(v)\n    ) as (Ast.Macro | Ast.String)[];\n    return ret;\n}\n\n/**\n * Lays out the contents of a \\systeme{...} macro as an array. This function sorts the variables\n * in alphabetical order and lays out any annotations. An `\\begin{array}...\\end{array}` environment\n * is returned.\n *\n * If `properSpacing=true` then kerning information will be included in the array specification to space\n * the operators correctly. This kerning information will make the specification long (and may make it incompatible\n * with KaTeX).\n *\n * An optional whitelist of variables may be supplied. If supplied, only listed items will count as variables and\n * the order of variable appearance will be the same as the order of the whitelisted variables.\n */\nexport function systemeContentsToArray(\n    nodes: Ast.Node[],\n    options?: {\n        properSpacing?: boolean;\n        whitelistedVariables?: (string | Ast.String | Ast.Macro)[];\n    }\n) {\n    nodes = structuredClone(nodes);\n    deleteComments(nodes);\n    const { properSpacing = true, whitelistedVariables } = options || {};\n    const coercedWhitelistedVariables =\n        normalizeVariableWhitelist(whitelistedVariables);\n    const systemeAst = parse(nodes, { whitelistedVariables });\n    const vars = extractVariables(systemeAst);\n    const varOrder = sortVariables(vars, coercedWhitelistedVariables);\n    let numVars = coercedWhitelistedVariables\n        ? coercedWhitelistedVariables.length\n        : Math.max(...Array.from(varOrder.values())) + 1;\n    // If there are terms with no variable, we need a spot for them\n    if (\n        systemeAst.some((line) => {\n            if (line.equation) {\n                return line.equation.left.some((item) => item.variable == null);\n            }\n        })\n    ) {\n        numVars += 1;\n    }\n    const hasEquals = systemeAst.some(\n        (line) => line.equation && line.equation.equals\n    );\n    const hasAnnotation = systemeAst.some((line) => line.annotation);\n\n    let rows = systemeAst.map((line) =>\n        processLine(line, numVars, varOrder, hasEquals, hasAnnotation)\n    );\n    // If we have no leading `-` signs (e.g., only leading `+` or bank signs)\n    // We don't need space for the first operation to be stored\n    const noLeadingOperation = rows.every((row) => row[0].length === 0);\n\n    // Every item in an equation has a centered operation and a right-aligned variable part.\n    let arraySignature = Array.from({ length: numVars }, () => \"cr\").join(\"\");\n    if (noLeadingOperation) {\n        // We might not have a leading operation on the first item(s)\n        arraySignature = arraySignature.slice(1);\n        rows = rows.map((row) => row.slice(1));\n    }\n    if (hasEquals) {\n        // The part after the equals is left-aligned\n        arraySignature += \"l\";\n    }\n    if (hasAnnotation) {\n        // The annotation is left-aligned\n        arraySignature += \"l\";\n        // We also manually insert space in front of any annotation\n        rows = rows.map((row) => {\n            if (row[row.length - 1].length === 0) {\n                return row;\n            }\n            return [\n                ...row.slice(0, row.length - 1),\n                [QUAD, { type: \"whitespace\" }, ...row[row.length - 1]],\n            ];\n        });\n    }\n\n    // By default, the array signature will put lots of space between items.\n    // We can correct for that manually.\n    const arraySignatureWithSpacing: Ast.Node[] = properSpacing\n        ? arraySpecToSpacedArraySpec(arraySignature, hasAnnotation)\n        : [{ type: \"string\", content: arraySignature }];\n\n    const bodyRows = rows.map((row) => arrayJoin(row, AMP));\n    const body = arrayJoin(bodyRows, SEP);\n\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: \"array\",\n        args: [\n            {\n                type: \"argument\",\n                openMark: \"{\",\n                closeMark: \"}\",\n                content: arraySignatureWithSpacing,\n            },\n        ],\n        content: body,\n    };\n\n    return ret;\n}\n\n/**\n * Find any systeme definitions, e.g. `\\sysdelim{.}{.}`, and attach their information\n * to the renderInfo of of the systeme macros.\n *\n */\nexport function attachSystemeSettingsAsRenderInfo(ast: Ast.Ast) {\n    const systemeMatcher = match.createMacroMatcher([\"systeme\", \"sysdelim\"]);\n\n    visit(\n        ast,\n        (nodes, info) => {\n            if (!info.context.inMathMode || !nodes.some(systemeMatcher)) {\n                return;\n            }\n            // Find the positions of the systeme and sysdelim macros\n            const systemeLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"systeme\") ? i : []\n            );\n            const sysdelimLocations = nodes.flatMap((node, i) =>\n                match.macro(node, \"sysdelim\") ? i : []\n            );\n\n            if (\n                systemeLocations.length === 0 ||\n                sysdelimLocations.length === 0\n            ) {\n                return;\n            }\n\n            for (const i of systemeLocations) {\n                // Find any sysdelim macros that occur before\n                const lastSysdelim = Math.max(\n                    ...sysdelimLocations.filter((loc) => loc < i)\n                );\n                if (lastSysdelim >= 0) {\n                    const node = nodes[i];\n                    const sysdelimMacro = nodes[lastSysdelim];\n                    if (!match.anyMacro(sysdelimMacro)) {\n                        throw new Error(\n                            `Expecting sysdelim macro but found \"${printRaw(\n                                sysdelimMacro\n                            )}\"`\n                        );\n                    }\n                    const args = getArgsContent(sysdelimMacro);\n                    updateRenderInfo(node, { sysdelims: args });\n                }\n            }\n        },\n        {\n            test: Array.isArray,\n            includeArrays: true,\n        }\n    );\n}\n", "// @ts-nocheck\n\n// globalThis polyfill from https://mathiasbynens.be/notes/globalthis\n(function () {\n    if (typeof globalThis === \"object\") return;\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n        get: function () {\n            return this;\n        },\n        configurable: true, // This makes it possible to `delete` the getter later.\n    });\n    __magic__.globalThis = __magic__; // lolwat\n    delete Object.prototype.__magic__;\n})();\n\nconst clone =\n    typeof globalThis.structuredClone === \"function\"\n        ? globalThis.structuredClone\n        : (obj: any) => JSON.parse(JSON.stringify(obj));\n\n/**\n * Wrapper around the built-in structured clone. Uses `JSON.parse(JSON.stringify(...))`\n * as a fallback.\n */\nexport function structuredClone<T>(obj: T): T {\n    return clone(obj);\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    pgfkeys: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzoption: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzstyle: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usetikzlibrary: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    pgfplotsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    pgfplotstabletypeset: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    tikzpicture: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n    axis: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n};\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    substitutecolormodel: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    selectcolormodel: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    colorlet: {\n        signature: \"o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolorset: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DefineNamedColor: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    color: { signature: \"o m\", renderInfo: { breakAround: true } },\n    textcolor: { signature: \"o m m\", renderInfo: { inParMode: true } },\n    pagecolor: { signature: \"o m\" },\n    colorbox: { signature: \"o m m\" },\n    fcolorbox: { signature: \"o m o m m\" },\n    boxframe: { signature: \"o m\" },\n    testcolor: { signature: \"o m\" },\n    blendcolors: { signature: \"s m\" },\n    maskcolors: { signature: \"o m\" },\n    definecolorseries: {\n        signature: \"m m m o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcolorseries: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true },\n    },\n    rowcolors: { signature: \"s o m m m\" },\n    extractcolorspec: { signature: \"m m\" },\n    extractcolorspecs: { signature: \"m m m\" },\n    convertcolorspec: { signature: \"m m m m\" },\n};\n\nexport const environments: EnvInfoRecord = {\n    testcolors: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n};\n", "import Color from \"color\";\nimport { DVI_PS_NAMES, SVG_NAMES, X11_NAMES } from \"./predefined-colors\";\nimport { XColor } from \"./types\";\nimport { parse as xcolorParser } from \"./parser\";\n\nconst CORE_MODELS = new Set([\"rgb\", \"cmy\", \"cmyk\", \"hsb\", \"gray\"]);\n\nexport const XColorCoreModelToColor = {\n    rgb: ([r, g, b]: number[]) => Color([r * 255, g * 255, b * 255], \"rgb\"),\n    cmy: ([c, m, y]: number[]) =>\n        XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),\n    cmyk: ([c, m, y, k]: number[]) =>\n        Color([c * 255, m * 255, y * 255, k * 100], \"cmyk\"),\n    hsb: ([h, s, b]: number[]) => Color([h * 360, s * 100, b * 100], \"hsv\"),\n    gray: ([v]: number[]) => Color([v * 255, v * 255, v * 255], \"rgb\"),\n};\nconst XColorModelToColor = {\n    wave: ([lambda]: number[]) => {\n        // Constants according to the xcolor readme\n        const gamma = 0.8;\n        let baseRgb = [0, 0, 0];\n        if (380 <= lambda && lambda < 440) {\n            baseRgb = [(440 - lambda) / (440 - 380), 0, 1];\n        }\n        if (440 <= lambda && lambda < 490) {\n            baseRgb = [0, (lambda - 440) / (490 - 440), 1];\n        }\n        if (490 <= lambda && lambda < 510) {\n            baseRgb = [0, 1, (510 - lambda) / (510 - 490)];\n        }\n        if (510 <= lambda && lambda < 580) {\n            baseRgb = [(lambda - 510) / (580 - 510), 1, 0];\n        }\n        if (580 <= lambda && lambda < 6450) {\n            baseRgb = [1, (645 - lambda) / (645 - 580), 0];\n        }\n        if (645 <= lambda && lambda <= 780) {\n            baseRgb = [1, 0, 0];\n        }\n        let f = 1.0;\n        if (380 <= lambda && 420 < lambda) {\n            f = 0.3 + (0.7 * (lambda - 380)) / (420 - 380);\n        }\n        if (700 < lambda && lambda <= 780) {\n            f = 0.3 + (0.7 * (780 - lambda)) / (780 - 700);\n        }\n\n        const rgb = [\n            Math.pow(baseRgb[0] * f, gamma),\n            Math.pow(baseRgb[1] * f, gamma),\n            Math.pow(baseRgb[2] * f, gamma),\n        ];\n\n        return Color([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], \"rgb\");\n    },\n    Hsb: ([h, s, b]: number[]) => XColorCoreModelToColor.hsb([h / 360, s, b]),\n    HSB: ([h, s, b]: number[]) =>\n        XColorCoreModelToColor.hsb([h / 240, s / 240, b / 240]),\n    HTML: ([v]: [string]) => (v.startsWith(\"#\") ? Color(v) : Color(`#${v}`)),\n    RGB: ([r, g, b]: number[]) => Color([r, g, b], \"rgb\"),\n    Gray: ([v]: number[]) => XColorCoreModelToColor.gray([v / 15]),\n    ...XColorCoreModelToColor,\n};\n\nconst ColorToXColorModel = {\n    rgb: (color: Color<any>) =>\n        color\n            .rgb()\n            .array()\n            .map((v) => v / 255),\n    cmy: (color: Color<any>) =>\n        [255 - color.red(), 255 - color.green(), 255 - color.blue()].map(\n            (v) => v / 255\n        ),\n    cmyk: (color: Color<any>) =>\n        color\n            .cmyk()\n            .array()\n            // The k component goes from 0-100\n            .map((v, i) => (i === 3 ? v / 100 : v / 255)),\n    hsb: (color: Color<any>) => [\n        color.hue() / 360,\n        color.saturationv() / 100,\n        color.value() / 100,\n    ],\n    gray: (color: Color<any>) => [color.gray() / 100],\n};\n\nexport const PREDEFINED_XCOLOR_COLORS: Record<string, Color<any>> = {\n    // Core colors\n    red: XColorCoreModelToColor.rgb([1, 0, 0]),\n    green: XColorCoreModelToColor.rgb([0, 1, 0]),\n    blue: XColorCoreModelToColor.rgb([0, 0, 1]),\n    brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),\n    lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),\n    orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),\n    pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),\n    purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),\n    teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),\n    violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),\n    cyan: XColorCoreModelToColor.rgb([0, 1, 1]),\n    magenta: XColorCoreModelToColor.rgb([1, 0, 1]),\n    yellow: XColorCoreModelToColor.rgb([1, 1, 0]),\n    olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),\n    black: XColorCoreModelToColor.rgb([0, 0, 0]),\n    darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),\n    gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),\n    lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),\n    white: XColorCoreModelToColor.rgb([1, 1, 1]),\n    ...DVI_PS_NAMES,\n    ...SVG_NAMES,\n    ...X11_NAMES,\n};\n\nfunction scalarMul(scalar: number, vec: number[]) {\n    return vec.map((v) => scalar * v);\n}\nfunction addVectors(...vecs: number[][]) {\n    return vecs.reduce((prev, current) => prev.map((v, i) => v + current[i]));\n}\n\n/**\n * Mix a color in color model `model` as per the algorithm in 2.3.3 of the xcolor manual.\n */\nfunction mixInModel(\n    model: string,\n    colorsAndCoefficients: [number, Color<any>][]\n): Color<any> {\n    if (!CORE_MODELS.has(model)) {\n        throw new Error(\n            `Cannot mix colors in model \"${model}\"; only core modes ${Array.from(\n                CORE_MODELS\n            ).join(\", \")} are supported`\n        );\n    }\n    const toModel =\n        ColorToXColorModel[model as keyof typeof ColorToXColorModel];\n    const fromModel =\n        XColorCoreModelToColor[model as keyof typeof XColorCoreModelToColor];\n\n    const mixed = addVectors(\n        ...colorsAndCoefficients.map(([v, color]) => {\n            const colorInModel = toModel(color);\n            return scalarMul(v, colorInModel);\n        })\n    );\n    return fromModel(mixed);\n}\n\n/**\n * Given a parsed `XColor`, compute the color and return a `Color` object\n * (that can be used in CSS, for example).\n */\nexport function computeColor(\n    expr: XColor,\n    predefinedColors: Record<string, Color<any>> = {}\n): Color<any> {\n    if (expr.type !== \"color\") {\n        throw new Error(\n            `Can only compute the color of a \"color\" expression, not one of type ${expr.type}`\n        );\n    }\n\n    const knownColors = { ...PREDEFINED_XCOLOR_COLORS, ...predefinedColors };\n    function getColor(name: string) {\n        if (!knownColors[name]) {\n            throw new Error(`Unknown color \"${name}\"`);\n        }\n        return knownColors[name];\n    }\n\n    const color = expr.color;\n    let computedColor = Color(\"#000000\");\n    if (color.type === \"expr\") {\n        // From the algorithm in 2.3.2 of the xcolor manual\n\n        // TODO: the suffix `!![num]` is not yet implemented.\n        let base = getColor(color.name);\n        for (const mix of color.mix_expr) {\n            if (mix.type === \"complete_mix\") {\n                const mixColor = getColor(mix.name);\n                base = base.mix(mixColor, 1 - mix.mix_percent / 100);\n            } else if (mix.type === \"partial_mix\") {\n                base = base.mix(Color(\"#FFFFFF\"), 1 - mix.mix_percent / 100);\n            }\n        }\n        if (color.prefix && color.prefix.length % 2 === 1) {\n            base = base.rotate(180);\n        }\n        computedColor = base;\n    }\n    if (color.type === \"extended_expr\") {\n        const model = color.core_model;\n        const div =\n            color.div ||\n            color.expressions.reduce((a, expr) => a + expr.weight, 0);\n        if (div <= 0) {\n            throw new Error(\n                `Cannot mix color with ratios that have a denominator of ${div}`\n            );\n        }\n        const colorsToMix: [number, Color<any>][] = color.expressions.map(\n            (expr) => [\n                expr.weight / div,\n                computeColor({\n                    type: \"color\",\n                    color: expr.color,\n                    functions: [],\n                }),\n            ]\n        );\n        computedColor = mixInModel(model, colorsToMix);\n    }\n\n    // Now we apply any color functions\n    for (const func of expr.functions) {\n        if (func.name === \"wheel\") {\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360);\n        }\n        if (func.name === \"twheel\") {\n            // This function depends on the definition of \\rangetHsb, which we\n            // don't actually know, so we just use it's default, which is to\n            // add a 60 deg. angle to everything. I think...\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360 + 60);\n        }\n    }\n\n    return computedColor;\n}\n\n/**\n * Convert the xcolor defined color to RGB Hex representation.\n * If the color is unknown or cannot be computed, `null` is returned.\n *\n * If `model` is supplied,\n *\n * The most likely reason a color will be `null` is if the color is defined\n * using a pre-defined color that wasn't supplied as an argument.\n */\nexport function xcolorColorToHex(\n    color: string,\n    model?: string | null,\n    options: {\n        predefinedColors?: Record<string, Color<any>>;\n    } = { predefinedColors: {} }\n): string | null {\n    const { predefinedColors = {} } = options;\n    const parsed = xcolorParser(color);\n    // If a model was entered, the corresponding color was directly entered without\n    // mixing, unless the parsed type was \"color\". This would through an error in `xcolor`,\n    // but we won't error.\n    if (model && model !== \"default\" && parsed.type !== \"color\") {\n        if (!(model in XColorModelToColor)) {\n            throw new Error(\n                `Unknown color model \"${model}\"; known models are ${Object.keys(\n                    XColorModelToColor\n                ).join(\", \")}`\n            );\n        }\n        if (parsed.type !== \"hex_spec\" && parsed.type !== \"num_spec\") {\n            throw new Error(\n                `Cannot use model ${model} to compute the color \"${color}\"`\n            );\n        }\n\n        if (model === \"HTML\" && parsed.type === \"hex_spec\") {\n            return XColorModelToColor.HTML(parsed.content).hex();\n        } else if (parsed.type === \"num_spec\") {\n            type x = keyof Omit<typeof XColorModelToColor, \"HTML\">;\n            return XColorModelToColor[\n                model as keyof Omit<typeof XColorModelToColor, \"HTML\">\n            ](parsed.content).hex();\n        }\n\n        throw new Error(\n            `Don't know how to process color \"${color}\" in model \"${model}\"`\n        );\n    }\n\n    if (Array.isArray(parsed) || parsed.type !== \"color\") {\n        throw new Error(\n            `Cannot the color \"${color}\" is not a valid color string`\n        );\n    }\n    let computed: Color<any> | null = null;\n    try {\n        computed = computeColor(parsed, predefinedColors);\n    } catch (e) {}\n\n    return computed && computed.hex();\n}\n", "import Color from \"color\";\n\nconst fromRgb = ([r, g, b]: number[]) =>\n    Color([r * 255, g * 255, b * 255], \"rgb\");\n\nexport const DVI_PS_NAMES = {\n    Apricot: Color(\"#FBB982\"),\n    Aquamarine: Color(\"#00B5BE\"),\n    Bittersweet: Color(\"#C04F17\"),\n    Black: Color(\"#221E1F\"),\n    Blue: Color(\"#2D2F92\"),\n    BlueGreen: Color(\"#00B3B8\"),\n    BlueViolet: Color(\"#473992\"),\n    BrickRed: Color(\"#B6321C\"),\n    Brown: Color(\"#792500\"),\n    BurntOrange: Color(\"#F7921D\"),\n    CadetBlue: Color(\"#74729A\"),\n    CarnationPink: Color(\"#F282B4\"),\n    Cerulean: Color(\"#00A2E3\"),\n    CornflowerBlue: Color(\"#41B0E4\"),\n    Cyan: Color(\"#00AEEF\"),\n    Dandelion: Color(\"#FDBC42\"),\n    DarkOrchid: Color(\"#A4538A\"),\n    Emerald: Color(\"#00A99D\"),\n    ForestGreen: Color(\"#009B55\"),\n    Fuchsia: Color(\"#8C368C\"),\n    Goldenrod: Color(\"#FFDF42\"),\n    Gray: Color(\"#949698\"),\n    Green: Color(\"#00A64F\"),\n    GreenYellow: Color(\"#DFE674\"),\n    JungleGreen: Color(\"#00A99A\"),\n    Lavender: Color(\"#F49EC4\"),\n    LimeGreen: Color(\"#8DC73E\"),\n    Magenta: Color(\"#EC008C\"),\n    Mahogany: Color(\"#A9341F\"),\n    Maroon: Color(\"#AF3235\"),\n    Melon: Color(\"#F89E7B\"),\n    MidnightBlue: Color(\"#006795\"),\n    Mulberry: Color(\"#A93C93\"),\n    NavyBlue: Color(\"#006EB8\"),\n    OliveGreen: Color(\"#3C8031\"),\n    Orange: Color(\"#F58137\"),\n    OrangeRed: Color(\"#ED135A\"),\n    Orchid: Color(\"#AF72B0\"),\n    Peach: Color(\"#F7965A\"),\n    Periwinkle: Color(\"#7977B8\"),\n    PineGreen: Color(\"#008B72\"),\n    Plum: Color(\"#92268F\"),\n    ProcessBlue: Color(\"#00B0F0\"),\n    Purple: Color(\"#99479B\"),\n    RawSienna: Color(\"#974006\"),\n    Red: Color(\"#ED1B23\"),\n    RedOrange: Color(\"#F26035\"),\n    RedViolet: Color(\"#A1246B\"),\n    Rhodamine: Color(\"#EF559F\"),\n    RoyalBlue: Color(\"#0071BC\"),\n    RoyalPurple: Color(\"#613F99\"),\n    RubineRed: Color(\"#ED017D\"),\n    Salmon: Color(\"#F69289\"),\n    SeaGreen: Color(\"#3FBC9D\"),\n    Sepia: Color(\"#671800\"),\n    SkyBlue: Color(\"#46C5DD\"),\n    SpringGreen: Color(\"#C6DC67\"),\n    Tan: Color(\"#DA9D76\"),\n    TealBlue: Color(\"#00AEB3\"),\n    Thistle: Color(\"#D883B7\"),\n    Turquoise: Color(\"#00B4CE\"),\n    Violet: Color(\"#58429B\"),\n    VioletRed: Color(\"#EF58A0\"),\n    White: Color(\"#FFFFFF\"),\n    WildStrawberry: Color(\"#EE2967\"),\n    Yellow: Color(\"#FFF200\"),\n    YellowGreen: Color(\"#98CC70\"),\n    YellowOrange: Color(\"#FAA21A\"),\n};\n\nexport const SVG_NAMES = {\n    AliceBlue: fromRgb([0.94, 0.972, 1]),\n    AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),\n    Aqua: fromRgb([0, 1, 1]),\n    Aquamarine: fromRgb([0.498, 1, 0.83]),\n    Azure: fromRgb([0.94, 1, 1]),\n    Beige: fromRgb([0.96, 0.96, 0.864]),\n    Bisque: fromRgb([1, 0.894, 0.77]),\n    Black: fromRgb([0, 0, 0]),\n    BlanchedAlmond: fromRgb([1, 0.92, 0.804]),\n    Blue: fromRgb([0, 0, 1]),\n    BlueViolet: fromRgb([0.54, 0.17, 0.888]),\n    Brown: fromRgb([0.648, 0.165, 0.165]),\n    BurlyWood: fromRgb([0.87, 0.72, 0.53]),\n    CadetBlue: fromRgb([0.372, 0.62, 0.628]),\n    Chartreuse: fromRgb([0.498, 1, 0]),\n    Chocolate: fromRgb([0.824, 0.41, 0.116]),\n    Coral: fromRgb([1, 0.498, 0.312]),\n    CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),\n    Cornsilk: fromRgb([1, 0.972, 0.864]),\n    Crimson: fromRgb([0.864, 0.08, 0.235]),\n    Cyan: fromRgb([0, 1, 1]),\n    DarkBlue: fromRgb([0, 0, 0.545]),\n    DarkCyan: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),\n    DarkGray: fromRgb([0.664, 0.664, 0.664]),\n    DarkGreen: fromRgb([0, 0.392, 0]),\n    DarkGrey: fromRgb([0.664, 0.664, 0.664]),\n    DarkKhaki: fromRgb([0.74, 0.716, 0.42]),\n    DarkMagenta: fromRgb([0.545, 0, 0.545]),\n    DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),\n    DarkOrange: fromRgb([1, 0.55, 0]),\n    DarkOrchid: fromRgb([0.6, 0.196, 0.8]),\n    DarkRed: fromRgb([0.545, 0, 0]),\n    DarkSalmon: fromRgb([0.912, 0.59, 0.48]),\n    DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),\n    DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),\n    DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),\n    DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),\n    DarkTurquoise: fromRgb([0, 0.808, 0.82]),\n    DarkViolet: fromRgb([0.58, 0, 0.828]),\n    DeepPink: fromRgb([1, 0.08, 0.576]),\n    DeepSkyBlue: fromRgb([0, 0.75, 1]),\n    DimGray: fromRgb([0.41, 0.41, 0.41]),\n    DimGrey: fromRgb([0.41, 0.41, 0.41]),\n    DodgerBlue: fromRgb([0.116, 0.565, 1]),\n    FireBrick: fromRgb([0.698, 0.132, 0.132]),\n    FloralWhite: fromRgb([1, 0.98, 0.94]),\n    ForestGreen: fromRgb([0.132, 0.545, 0.132]),\n    Fuchsia: fromRgb([1, 0, 1]),\n    Gainsboro: fromRgb([0.864, 0.864, 0.864]),\n    GhostWhite: fromRgb([0.972, 0.972, 1]),\n    Gold: fromRgb([1, 0.844, 0]),\n    Goldenrod: fromRgb([0.855, 0.648, 0.125]),\n    Gray: fromRgb([0.5, 0.5, 0.5]),\n    Green: fromRgb([0, 0.5, 0]),\n    GreenYellow: fromRgb([0.68, 1, 0.185]),\n    Grey: fromRgb([0.5, 0.5, 0.5]),\n    Honeydew: fromRgb([0.94, 1, 0.94]),\n    HotPink: fromRgb([1, 0.41, 0.705]),\n    IndianRed: fromRgb([0.804, 0.36, 0.36]),\n    Indigo: fromRgb([0.294, 0, 0.51]),\n    Ivory: fromRgb([1, 1, 0.94]),\n    Khaki: fromRgb([0.94, 0.9, 0.55]),\n    Lavender: fromRgb([0.9, 0.9, 0.98]),\n    LavenderBlush: fromRgb([1, 0.94, 0.96]),\n    LawnGreen: fromRgb([0.488, 0.99, 0]),\n    LemonChiffon: fromRgb([1, 0.98, 0.804]),\n    LightBlue: fromRgb([0.68, 0.848, 0.9]),\n    LightCoral: fromRgb([0.94, 0.5, 0.5]),\n    LightCyan: fromRgb([0.88, 1, 1]),\n    LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),\n    LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),\n    LightGray: fromRgb([0.828, 0.828, 0.828]),\n    LightGreen: fromRgb([0.565, 0.932, 0.565]),\n    LightGrey: fromRgb([0.828, 0.828, 0.828]),\n    LightPink: fromRgb([1, 0.712, 0.756]),\n    LightSalmon: fromRgb([1, 0.628, 0.48]),\n    LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),\n    LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),\n    LightSlateBlue: fromRgb([0.518, 0.44, 1]),\n    LightSlateGray: fromRgb([0.468, 0.532, 0.6]),\n    LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),\n    LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),\n    LightYellow: fromRgb([1, 1, 0.88]),\n    Lime: fromRgb([0, 1, 0]),\n    LimeGreen: fromRgb([0.196, 0.804, 0.196]),\n    Linen: fromRgb([0.98, 0.94, 0.9]),\n    Magenta: fromRgb([1, 0, 1]),\n    Maroon: fromRgb([0.5, 0, 0]),\n    MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),\n    MediumBlue: fromRgb([0, 0, 0.804]),\n    MediumOrchid: fromRgb([0.73, 0.332, 0.828]),\n    MediumPurple: fromRgb([0.576, 0.44, 0.86]),\n    MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),\n    MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),\n    MediumSpringGreen: fromRgb([0, 0.98, 0.604]),\n    MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),\n    MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),\n    MidnightBlue: fromRgb([0.098, 0.098, 0.44]),\n    MintCream: fromRgb([0.96, 1, 0.98]),\n    MistyRose: fromRgb([1, 0.894, 0.884]),\n    Moccasin: fromRgb([1, 0.894, 0.71]),\n    NavajoWhite: fromRgb([1, 0.87, 0.68]),\n    Navy: fromRgb([0, 0, 0.5]),\n    NavyBlue: fromRgb([0, 0, 0.5]),\n    OldLace: fromRgb([0.992, 0.96, 0.9]),\n    Olive: fromRgb([0.5, 0.5, 0]),\n    OliveDrab: fromRgb([0.42, 0.556, 0.136]),\n    Orange: fromRgb([1, 0.648, 0]),\n    OrangeRed: fromRgb([1, 0.27, 0]),\n    Orchid: fromRgb([0.855, 0.44, 0.84]),\n    PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),\n    PaleGreen: fromRgb([0.596, 0.985, 0.596]),\n    PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),\n    PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),\n    PapayaWhip: fromRgb([1, 0.936, 0.835]),\n    PeachPuff: fromRgb([1, 0.855, 0.725]),\n    Peru: fromRgb([0.804, 0.52, 0.248]),\n    Pink: fromRgb([1, 0.752, 0.796]),\n    Plum: fromRgb([0.868, 0.628, 0.868]),\n    PowderBlue: fromRgb([0.69, 0.88, 0.9]),\n    Purple: fromRgb([0.5, 0, 0.5]),\n    Red: fromRgb([1, 0, 0]),\n    RosyBrown: fromRgb([0.736, 0.56, 0.56]),\n    RoyalBlue: fromRgb([0.255, 0.41, 0.884]),\n    SaddleBrown: fromRgb([0.545, 0.27, 0.075]),\n    Salmon: fromRgb([0.98, 0.5, 0.448]),\n    SandyBrown: fromRgb([0.956, 0.644, 0.376]),\n    SeaGreen: fromRgb([0.18, 0.545, 0.34]),\n    Seashell: fromRgb([1, 0.96, 0.932]),\n    Sienna: fromRgb([0.628, 0.32, 0.176]),\n    Silver: fromRgb([0.752, 0.752, 0.752]),\n    SkyBlue: fromRgb([0.53, 0.808, 0.92]),\n    SlateBlue: fromRgb([0.415, 0.352, 0.804]),\n    SlateGray: fromRgb([0.44, 0.5, 0.565]),\n    SlateGrey: fromRgb([0.44, 0.5, 0.565]),\n    Snow: fromRgb([1, 0.98, 0.98]),\n    SpringGreen: fromRgb([0, 1, 0.498]),\n    SteelBlue: fromRgb([0.275, 0.51, 0.705]),\n    Tan: fromRgb([0.824, 0.705, 0.55]),\n    Teal: fromRgb([0, 0.5, 0.5]),\n    Thistle: fromRgb([0.848, 0.75, 0.848]),\n    Tomato: fromRgb([1, 0.39, 0.28]),\n    Turquoise: fromRgb([0.25, 0.88, 0.815]),\n    Violet: fromRgb([0.932, 0.51, 0.932]),\n    VioletRed: fromRgb([0.816, 0.125, 0.565]),\n    Wheat: fromRgb([0.96, 0.87, 0.7]),\n    White: fromRgb([1, 1, 1]),\n    WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),\n    Yellow: fromRgb([1, 1, 0]),\n    YellowGreen: fromRgb([0.604, 0.804, 0.196]),\n};\n\nexport const X11_NAMES = {\n    AntiqueWhite1: fromRgb([1, 0.936, 0.86]),\n    AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),\n    AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),\n    AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),\n    Aquamarine1: fromRgb([0.498, 1, 0.83]),\n    Aquamarine2: fromRgb([0.464, 0.932, 0.776]),\n    Aquamarine3: fromRgb([0.4, 0.804, 0.668]),\n    Aquamarine4: fromRgb([0.27, 0.545, 0.455]),\n    Azure1: fromRgb([0.94, 1, 1]),\n    Azure2: fromRgb([0.88, 0.932, 0.932]),\n    Azure3: fromRgb([0.756, 0.804, 0.804]),\n    Azure4: fromRgb([0.512, 0.545, 0.545]),\n    Bisque1: fromRgb([1, 0.894, 0.77]),\n    Bisque2: fromRgb([0.932, 0.835, 0.716]),\n    Bisque3: fromRgb([0.804, 0.716, 0.62]),\n    Bisque4: fromRgb([0.545, 0.49, 0.42]),\n    Blue1: fromRgb([0, 0, 1]),\n    Blue2: fromRgb([0, 0, 0.932]),\n    Blue3: fromRgb([0, 0, 0.804]),\n    Blue4: fromRgb([0, 0, 0.545]),\n    Brown1: fromRgb([1, 0.25, 0.25]),\n    Brown2: fromRgb([0.932, 0.23, 0.23]),\n    Brown3: fromRgb([0.804, 0.2, 0.2]),\n    Brown4: fromRgb([0.545, 0.136, 0.136]),\n    Burlywood1: fromRgb([1, 0.828, 0.608]),\n    Burlywood2: fromRgb([0.932, 0.772, 0.57]),\n    Burlywood3: fromRgb([0.804, 0.668, 0.49]),\n    Burlywood4: fromRgb([0.545, 0.45, 0.332]),\n    CadetBlue1: fromRgb([0.596, 0.96, 1]),\n    CadetBlue2: fromRgb([0.556, 0.898, 0.932]),\n    CadetBlue3: fromRgb([0.48, 0.772, 0.804]),\n    CadetBlue4: fromRgb([0.325, 0.525, 0.545]),\n    Chartreuse1: fromRgb([0.498, 1, 0]),\n    Chartreuse2: fromRgb([0.464, 0.932, 0]),\n    Chartreuse3: fromRgb([0.4, 0.804, 0]),\n    Chartreuse4: fromRgb([0.27, 0.545, 0]),\n    Chocolate1: fromRgb([1, 0.498, 0.14]),\n    Chocolate2: fromRgb([0.932, 0.464, 0.13]),\n    Chocolate3: fromRgb([0.804, 0.4, 0.112]),\n    Chocolate4: fromRgb([0.545, 0.27, 0.075]),\n    Coral1: fromRgb([1, 0.448, 0.336]),\n    Coral2: fromRgb([0.932, 0.415, 0.312]),\n    Coral3: fromRgb([0.804, 0.356, 0.27]),\n    Coral4: fromRgb([0.545, 0.244, 0.185]),\n    Cornsilk1: fromRgb([1, 0.972, 0.864]),\n    Cornsilk2: fromRgb([0.932, 0.91, 0.804]),\n    Cornsilk3: fromRgb([0.804, 0.785, 0.694]),\n    Cornsilk4: fromRgb([0.545, 0.532, 0.47]),\n    Cyan1: fromRgb([0, 1, 1]),\n    Cyan2: fromRgb([0, 0.932, 0.932]),\n    Cyan3: fromRgb([0, 0.804, 0.804]),\n    Cyan4: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),\n    DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),\n    DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),\n    DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),\n    DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),\n    DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),\n    DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),\n    DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),\n    DarkOrange1: fromRgb([1, 0.498, 0]),\n    DarkOrange2: fromRgb([0.932, 0.464, 0]),\n    DarkOrange3: fromRgb([0.804, 0.4, 0]),\n    DarkOrange4: fromRgb([0.545, 0.27, 0]),\n    DarkOrchid1: fromRgb([0.75, 0.244, 1]),\n    DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),\n    DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),\n    DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),\n    DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),\n    DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),\n    DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),\n    DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),\n    DarkSlateGray1: fromRgb([0.592, 1, 1]),\n    DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),\n    DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),\n    DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),\n    DeepPink1: fromRgb([1, 0.08, 0.576]),\n    DeepPink2: fromRgb([0.932, 0.07, 0.536]),\n    DeepPink3: fromRgb([0.804, 0.064, 0.464]),\n    DeepPink4: fromRgb([0.545, 0.04, 0.312]),\n    DeepSkyBlue1: fromRgb([0, 0.75, 1]),\n    DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),\n    DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),\n    DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),\n    DodgerBlue1: fromRgb([0.116, 0.565, 1]),\n    DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),\n    DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),\n    DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),\n    Firebrick1: fromRgb([1, 0.19, 0.19]),\n    Firebrick2: fromRgb([0.932, 0.172, 0.172]),\n    Firebrick3: fromRgb([0.804, 0.15, 0.15]),\n    Firebrick4: fromRgb([0.545, 0.1, 0.1]),\n    Gold1: fromRgb([1, 0.844, 0]),\n    Gold2: fromRgb([0.932, 0.79, 0]),\n    Gold3: fromRgb([0.804, 0.68, 0]),\n    Gold4: fromRgb([0.545, 0.46, 0]),\n    Goldenrod1: fromRgb([1, 0.756, 0.145]),\n    Goldenrod2: fromRgb([0.932, 0.705, 0.132]),\n    Goldenrod3: fromRgb([0.804, 0.608, 0.112]),\n    Goldenrod4: fromRgb([0.545, 0.41, 0.08]),\n    Green1: fromRgb([0, 1, 0]),\n    Green2: fromRgb([0, 0.932, 0]),\n    Green3: fromRgb([0, 0.804, 0]),\n    Green4: fromRgb([0, 0.545, 0]),\n    Honeydew1: fromRgb([0.94, 1, 0.94]),\n    Honeydew2: fromRgb([0.88, 0.932, 0.88]),\n    Honeydew3: fromRgb([0.756, 0.804, 0.756]),\n    Honeydew4: fromRgb([0.512, 0.545, 0.512]),\n    HotPink1: fromRgb([1, 0.43, 0.705]),\n    HotPink2: fromRgb([0.932, 0.415, 0.655]),\n    HotPink3: fromRgb([0.804, 0.376, 0.565]),\n    HotPink4: fromRgb([0.545, 0.228, 0.385]),\n    IndianRed1: fromRgb([1, 0.415, 0.415]),\n    IndianRed2: fromRgb([0.932, 0.39, 0.39]),\n    IndianRed3: fromRgb([0.804, 0.332, 0.332]),\n    IndianRed4: fromRgb([0.545, 0.228, 0.228]),\n    Ivory1: fromRgb([1, 1, 0.94]),\n    Ivory2: fromRgb([0.932, 0.932, 0.88]),\n    Ivory3: fromRgb([0.804, 0.804, 0.756]),\n    Ivory4: fromRgb([0.545, 0.545, 0.512]),\n    Khaki1: fromRgb([1, 0.965, 0.56]),\n    Khaki2: fromRgb([0.932, 0.9, 0.52]),\n    Khaki3: fromRgb([0.804, 0.776, 0.45]),\n    Khaki4: fromRgb([0.545, 0.525, 0.305]),\n    LavenderBlush1: fromRgb([1, 0.94, 0.96]),\n    LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),\n    LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),\n    LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),\n    LemonChiffon1: fromRgb([1, 0.98, 0.804]),\n    LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),\n    LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),\n    LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),\n    LightBlue1: fromRgb([0.75, 0.936, 1]),\n    LightBlue2: fromRgb([0.698, 0.875, 0.932]),\n    LightBlue3: fromRgb([0.604, 0.752, 0.804]),\n    LightBlue4: fromRgb([0.408, 0.512, 0.545]),\n    LightCyan1: fromRgb([0.88, 1, 1]),\n    LightCyan2: fromRgb([0.82, 0.932, 0.932]),\n    LightCyan3: fromRgb([0.705, 0.804, 0.804]),\n    LightCyan4: fromRgb([0.48, 0.545, 0.545]),\n    LightGoldenrod1: fromRgb([1, 0.925, 0.545]),\n    LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),\n    LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),\n    LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),\n    LightPink1: fromRgb([1, 0.684, 0.725]),\n    LightPink2: fromRgb([0.932, 0.635, 0.68]),\n    LightPink3: fromRgb([0.804, 0.55, 0.585]),\n    LightPink4: fromRgb([0.545, 0.372, 0.396]),\n    LightSalmon1: fromRgb([1, 0.628, 0.48]),\n    LightSalmon2: fromRgb([0.932, 0.585, 0.448]),\n    LightSalmon3: fromRgb([0.804, 0.505, 0.385]),\n    LightSalmon4: fromRgb([0.545, 0.34, 0.26]),\n    LightSkyBlue1: fromRgb([0.69, 0.888, 1]),\n    LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),\n    LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),\n    LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),\n    LightSteelBlue1: fromRgb([0.792, 0.884, 1]),\n    LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),\n    LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),\n    LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),\n    LightYellow1: fromRgb([1, 1, 0.88]),\n    LightYellow2: fromRgb([0.932, 0.932, 0.82]),\n    LightYellow3: fromRgb([0.804, 0.804, 0.705]),\n    LightYellow4: fromRgb([0.545, 0.545, 0.48]),\n    Magenta1: fromRgb([1, 0, 1]),\n    Magenta2: fromRgb([0.932, 0, 0.932]),\n    Magenta3: fromRgb([0.804, 0, 0.804]),\n    Magenta4: fromRgb([0.545, 0, 0.545]),\n    Maroon1: fromRgb([1, 0.204, 0.7]),\n    Maroon2: fromRgb([0.932, 0.19, 0.655]),\n    Maroon3: fromRgb([0.804, 0.16, 0.565]),\n    Maroon4: fromRgb([0.545, 0.11, 0.385]),\n    MediumOrchid1: fromRgb([0.88, 0.4, 1]),\n    MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),\n    MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),\n    MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),\n    MediumPurple1: fromRgb([0.67, 0.51, 1]),\n    MediumPurple2: fromRgb([0.624, 0.475, 0.932]),\n    MediumPurple3: fromRgb([0.536, 0.408, 0.804]),\n    MediumPurple4: fromRgb([0.365, 0.28, 0.545]),\n    MistyRose1: fromRgb([1, 0.894, 0.884]),\n    MistyRose2: fromRgb([0.932, 0.835, 0.824]),\n    MistyRose3: fromRgb([0.804, 0.716, 0.71]),\n    MistyRose4: fromRgb([0.545, 0.49, 0.484]),\n    NavajoWhite1: fromRgb([1, 0.87, 0.68]),\n    NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),\n    NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),\n    NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),\n    OliveDrab1: fromRgb([0.752, 1, 0.244]),\n    OliveDrab2: fromRgb([0.7, 0.932, 0.228]),\n    OliveDrab3: fromRgb([0.604, 0.804, 0.196]),\n    OliveDrab4: fromRgb([0.41, 0.545, 0.132]),\n    Orange1: fromRgb([1, 0.648, 0]),\n    Orange2: fromRgb([0.932, 0.604, 0]),\n    Orange3: fromRgb([0.804, 0.52, 0]),\n    Orange4: fromRgb([0.545, 0.352, 0]),\n    OrangeRed1: fromRgb([1, 0.27, 0]),\n    OrangeRed2: fromRgb([0.932, 0.25, 0]),\n    OrangeRed3: fromRgb([0.804, 0.215, 0]),\n    OrangeRed4: fromRgb([0.545, 0.145, 0]),\n    Orchid1: fromRgb([1, 0.512, 0.98]),\n    Orchid2: fromRgb([0.932, 0.48, 0.912]),\n    Orchid3: fromRgb([0.804, 0.41, 0.79]),\n    Orchid4: fromRgb([0.545, 0.28, 0.536]),\n    PaleGreen1: fromRgb([0.604, 1, 0.604]),\n    PaleGreen2: fromRgb([0.565, 0.932, 0.565]),\n    PaleGreen3: fromRgb([0.488, 0.804, 0.488]),\n    PaleGreen4: fromRgb([0.33, 0.545, 0.33]),\n    PaleTurquoise1: fromRgb([0.732, 1, 1]),\n    PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),\n    PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),\n    PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),\n    PaleVioletRed1: fromRgb([1, 0.51, 0.67]),\n    PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),\n    PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),\n    PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),\n    PeachPuff1: fromRgb([1, 0.855, 0.725]),\n    PeachPuff2: fromRgb([0.932, 0.796, 0.68]),\n    PeachPuff3: fromRgb([0.804, 0.688, 0.585]),\n    PeachPuff4: fromRgb([0.545, 0.468, 0.396]),\n    Pink1: fromRgb([1, 0.71, 0.772]),\n    Pink2: fromRgb([0.932, 0.664, 0.72]),\n    Pink3: fromRgb([0.804, 0.57, 0.62]),\n    Pink4: fromRgb([0.545, 0.39, 0.424]),\n    Plum1: fromRgb([1, 0.732, 1]),\n    Plum2: fromRgb([0.932, 0.684, 0.932]),\n    Plum3: fromRgb([0.804, 0.59, 0.804]),\n    Plum4: fromRgb([0.545, 0.4, 0.545]),\n    Purple1: fromRgb([0.608, 0.19, 1]),\n    Purple2: fromRgb([0.57, 0.172, 0.932]),\n    Purple3: fromRgb([0.49, 0.15, 0.804]),\n    Purple4: fromRgb([0.332, 0.1, 0.545]),\n    Red1: fromRgb([1, 0, 0]),\n    Red2: fromRgb([0.932, 0, 0]),\n    Red3: fromRgb([0.804, 0, 0]),\n    Red4: fromRgb([0.545, 0, 0]),\n    RosyBrown1: fromRgb([1, 0.756, 0.756]),\n    RosyBrown2: fromRgb([0.932, 0.705, 0.705]),\n    RosyBrown3: fromRgb([0.804, 0.608, 0.608]),\n    RosyBrown4: fromRgb([0.545, 0.41, 0.41]),\n    RoyalBlue1: fromRgb([0.284, 0.464, 1]),\n    RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),\n    RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),\n    RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),\n    Salmon1: fromRgb([1, 0.55, 0.41]),\n    Salmon2: fromRgb([0.932, 0.51, 0.385]),\n    Salmon3: fromRgb([0.804, 0.44, 0.33]),\n    Salmon4: fromRgb([0.545, 0.298, 0.224]),\n    SeaGreen1: fromRgb([0.33, 1, 0.624]),\n    SeaGreen2: fromRgb([0.305, 0.932, 0.58]),\n    SeaGreen3: fromRgb([0.264, 0.804, 0.5]),\n    SeaGreen4: fromRgb([0.18, 0.545, 0.34]),\n    Seashell1: fromRgb([1, 0.96, 0.932]),\n    Seashell2: fromRgb([0.932, 0.898, 0.87]),\n    Seashell3: fromRgb([0.804, 0.772, 0.75]),\n    Seashell4: fromRgb([0.545, 0.525, 0.51]),\n    Sienna1: fromRgb([1, 0.51, 0.28]),\n    Sienna2: fromRgb([0.932, 0.475, 0.26]),\n    Sienna3: fromRgb([0.804, 0.408, 0.224]),\n    Sienna4: fromRgb([0.545, 0.28, 0.15]),\n    SkyBlue1: fromRgb([0.53, 0.808, 1]),\n    SkyBlue2: fromRgb([0.494, 0.752, 0.932]),\n    SkyBlue3: fromRgb([0.424, 0.65, 0.804]),\n    SkyBlue4: fromRgb([0.29, 0.44, 0.545]),\n    SlateBlue1: fromRgb([0.512, 0.435, 1]),\n    SlateBlue2: fromRgb([0.48, 0.404, 0.932]),\n    SlateBlue3: fromRgb([0.41, 0.35, 0.804]),\n    SlateBlue4: fromRgb([0.28, 0.235, 0.545]),\n    SlateGray1: fromRgb([0.776, 0.888, 1]),\n    SlateGray2: fromRgb([0.725, 0.828, 0.932]),\n    SlateGray3: fromRgb([0.624, 0.712, 0.804]),\n    SlateGray4: fromRgb([0.424, 0.484, 0.545]),\n    Snow1: fromRgb([1, 0.98, 0.98]),\n    Snow2: fromRgb([0.932, 0.912, 0.912]),\n    Snow3: fromRgb([0.804, 0.79, 0.79]),\n    Snow4: fromRgb([0.545, 0.536, 0.536]),\n    SpringGreen1: fromRgb([0, 1, 0.498]),\n    SpringGreen2: fromRgb([0, 0.932, 0.464]),\n    SpringGreen3: fromRgb([0, 0.804, 0.4]),\n    SpringGreen4: fromRgb([0, 0.545, 0.27]),\n    SteelBlue1: fromRgb([0.39, 0.72, 1]),\n    SteelBlue2: fromRgb([0.36, 0.675, 0.932]),\n    SteelBlue3: fromRgb([0.31, 0.58, 0.804]),\n    SteelBlue4: fromRgb([0.21, 0.392, 0.545]),\n    Tan1: fromRgb([1, 0.648, 0.31]),\n    Tan2: fromRgb([0.932, 0.604, 0.288]),\n    Tan3: fromRgb([0.804, 0.52, 0.248]),\n    Tan4: fromRgb([0.545, 0.352, 0.17]),\n    Thistle1: fromRgb([1, 0.884, 1]),\n    Thistle2: fromRgb([0.932, 0.824, 0.932]),\n    Thistle3: fromRgb([0.804, 0.71, 0.804]),\n    Thistle4: fromRgb([0.545, 0.484, 0.545]),\n    Tomato1: fromRgb([1, 0.39, 0.28]),\n    Tomato2: fromRgb([0.932, 0.36, 0.26]),\n    Tomato3: fromRgb([0.804, 0.31, 0.224]),\n    Tomato4: fromRgb([0.545, 0.21, 0.15]),\n    Turquoise1: fromRgb([0, 0.96, 1]),\n    Turquoise2: fromRgb([0, 0.898, 0.932]),\n    Turquoise3: fromRgb([0, 0.772, 0.804]),\n    Turquoise4: fromRgb([0, 0.525, 0.545]),\n    VioletRed1: fromRgb([1, 0.244, 0.59]),\n    VioletRed2: fromRgb([0.932, 0.228, 0.55]),\n    VioletRed3: fromRgb([0.804, 0.196, 0.47]),\n    VioletRed4: fromRgb([0.545, 0.132, 0.32]),\n    Wheat1: fromRgb([1, 0.905, 0.73]),\n    Wheat2: fromRgb([0.932, 0.848, 0.684]),\n    Wheat3: fromRgb([0.804, 0.73, 0.59]),\n    Wheat4: fromRgb([0.545, 0.494, 0.4]),\n    Yellow1: fromRgb([1, 1, 0]),\n    Yellow2: fromRgb([0.932, 0.932, 0]),\n    Yellow3: fromRgb([0.804, 0.804, 0]),\n    Yellow4: fromRgb([0.545, 0.545, 0]),\n    Gray0: fromRgb([0.745, 0.745, 0.745]),\n    Green0: fromRgb([0, 1, 0]),\n    Grey0: fromRgb([0.745, 0.745, 0.745]),\n    Maroon0: fromRgb([0.69, 0.19, 0.376]),\n    Purple0: fromRgb([0.628, 0.125, 0.94]),\n};\n", "import { XColorPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as XColorSpec from \"./types\";\n\nconst parseCache: Record<string, XColorSpec.Ast> = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): XColorSpec.Ast {\n    parseCache[str] =\n        parseCache[str] || (XColorPegParser.parse(str) as XColorSpec.Ast);\n    return parseCache[str];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { xcolorColorToHex } from \"./xcolor\";\nimport { structuredClone } from \"@unified-latex/structured-clone\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\n\n/**\n * Compute the hex representation of a color specified by an xcolor color command.\n * For example `\\color[rgb]{1 .5 .5}` or `\\textcolor{red}{foo}`. If the color cannot be parsed,\n * `null` is returned for the hex value. In all cases a css variable name (prefixed with \"--\"\")\n * is returned. This can be used to set up CSS for custom colors.\n */\nexport function xcolorMacroToHex(node: Ast.Macro): {\n    hex: string | null;\n    cssVarName: string;\n} {\n    // We do some destructive operations on the node, so clone it first.\n    node = structuredClone(node);\n    deleteComments(node);\n\n    // We assume the node has signature \"o m\" where o is the model and\n    // m is the color spec.\n\n    const args = getArgsContent(node);\n    const model = args[0] && printRaw(args[0]);\n    const colorStr = printRaw(args[1] || []);\n    let hex: string | null = null;\n    try {\n        hex = xcolorColorToHex(colorStr, model);\n    } catch (e) {}\n\n    const cssVarName = \"--\" + colorStr.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n\n    return { hex, cssVarName };\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Create a `\\textcolor` macro. Color arguments are taken from `origMacro`.\n */\nexport function colorToTextcolorMacro(\n    content: Ast.Node | Ast.Node[],\n    origMacro: Ast.Macro\n): Ast.Macro {\n    if (!Array.isArray(content)) {\n        content = [content];\n    }\n    // Signature of \\color is \"o m\".\n    // We want to carry through the same arguments\n    const args = (\n        origMacro.args\n            ? origMacro.args\n            : [arg([], { closeMark: \"\", openMark: \"\" }), arg([])]\n    ).concat(arg(content));\n\n    return {\n        type: \"macro\",\n        content: \"textcolor\",\n        args,\n        _renderInfo: { inParMode: true },\n    };\n}", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RequirePackage: {\n        signature: \"o m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n    DeclareOption: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import * as cleveref from \"./package/cleveref\";\nimport * as exam from \"./package/exam\";\nimport * as geometry from \"./package/geometry\";\nimport * as hyperref from \"./package/hyperref\";\nimport * as latex2e from \"./package/latex2e\";\nimport * as makeidx from \"./package/makeidx\";\nimport * as mathtools from \"./package/mathtools\";\nimport * as nicematrix from \"./package/nicematrix\";\nimport * as systeme from \"./package/systeme\";\nimport * as tikz from \"./package/tikz\";\nimport * as xcolor from \"./package/xcolor\";\nimport * as xparse from \"./package/xparse\";\n\n/**\n * Info about the macros for available ctan packages. `latex2e` contains\n * the standard macros for LaTeX.\n */\nexport const macroInfo = {\n    cleveref: cleveref.macros,\n    exam: exam.macros,\n    geometry: geometry.macros,\n    hyperref: hyperref.macros,\n    latex2e: latex2e.macros,\n    makeidx: makeidx.macros,\n    mathtools: mathtools.macros,\n    nicematrix: nicematrix.macros,\n    systeme: systeme.macros,\n    tikz: tikz.macros,\n    xcolor: xcolor.macros,\n    xparse: xparse.macros,\n};\n\n/**\n * Info about the environments for available ctan packages. `latex2e` contains\n * the standard environments for LaTeX.\n */\nexport const environmentInfo = {\n    cleveref: cleveref.environments,\n    exam: exam.environments,\n    geometry: geometry.environments,\n    hyperref: hyperref.environments,\n    latex2e: latex2e.environments,\n    makeidx: makeidx.environments,\n    mathtools: mathtools.environments,\n    nicematrix: nicematrix.environments,\n    systeme: systeme.environments,\n    tikz: tikz.environments,\n    xcolor: xcolor.environments,\n    xparse: xparse.environments,\n};\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Macro/environment definitions and utilities for specific LaTeX packages from CTAN.\n *\n * Note: basic LaTeX macro/environment definitions come from the `latex2e` package, even though\n * this is technically not a CTAN \"package\".\n *\n * ## When should I use this?\n *\n * If you want information about special functions/macros from particular CTAN packages, or\n * you need to parse special environments.\n */\n"],
  "mappings": "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",
  "names": []
}
