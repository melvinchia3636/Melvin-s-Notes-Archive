{
  "version": 3,
  "sources": ["../../../node_modules/prettier/doc.js", "../index.ts", "../libs/printer/common.ts", "../libs/zip.ts", "../libs/printer/macro.ts", "../libs/printer/argument.ts", "../libs/printer/root.ts", "../libs/printer/comment.ts", "../libs/printer/math.ts", "../libs/printer/environment.ts", "../libs/printer/printer.ts", "../libs/reference-map.ts", "../libs/prettier-plugin-latex.ts"],
  "sourcesContent": ["(function (factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    var root =\n      typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof self !== \"undefined\"\n        ? self\n        : this || {};\n    root.doc = factory();\n  }\n})(function() {\n  \"use strict\";\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\n  // dist/doc.js\n  var require_doc = __commonJS({\n    \"dist/doc.js\"(exports, module) {\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __esm = (fn, res) => function __init() {\n        return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n      };\n      var __commonJS2 = (cb, mod) => function __require() {\n        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n          exports: {}\n        }).exports, mod), mod.exports;\n      };\n      var init_define_process = __esm({\n        \"<define:process>\"() {\n        }\n      });\n      var require_doc_builders = __commonJS2({\n        \"src/document/doc-builders.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function concat(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"concat\",\n              parts\n            };\n          }\n          function indent(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"indent\",\n              contents\n            };\n          }\n          function align(widthOrString, contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"align\",\n              contents,\n              n: widthOrString\n            };\n          }\n          function group(contents) {\n            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"group\",\n              id: opts.id,\n              contents,\n              break: Boolean(opts.shouldBreak),\n              expandedStates: opts.expandedStates\n            };\n          }\n          function dedentToRoot(contents) {\n            return align(Number.NEGATIVE_INFINITY, contents);\n          }\n          function markAsRoot(contents) {\n            return align({\n              type: \"root\"\n            }, contents);\n          }\n          function dedent(contents) {\n            return align(-1, contents);\n          }\n          function conditionalGroup(states, opts) {\n            return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n              expandedStates: states\n            }));\n          }\n          function fill(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"fill\",\n              parts\n            };\n          }\n          function ifBreak(breakContents, flatContents) {\n            let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (false) {\n              if (breakContents) {\n                assertDoc(breakContents);\n              }\n              if (flatContents) {\n                assertDoc(flatContents);\n              }\n            }\n            return {\n              type: \"if-break\",\n              breakContents,\n              flatContents,\n              groupId: opts.groupId\n            };\n          }\n          function indentIfBreak(contents, opts) {\n            return {\n              type: \"indent-if-break\",\n              contents,\n              groupId: opts.groupId,\n              negate: opts.negate\n            };\n          }\n          function lineSuffix(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"line-suffix\",\n              contents\n            };\n          }\n          var lineSuffixBoundary = {\n            type: \"line-suffix-boundary\"\n          };\n          var breakParent = {\n            type: \"break-parent\"\n          };\n          var trim = {\n            type: \"trim\"\n          };\n          var hardlineWithoutBreakParent = {\n            type: \"line\",\n            hard: true\n          };\n          var literallineWithoutBreakParent = {\n            type: \"line\",\n            hard: true,\n            literal: true\n          };\n          var line = {\n            type: \"line\"\n          };\n          var softline = {\n            type: \"line\",\n            soft: true\n          };\n          var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n          var literalline = concat([literallineWithoutBreakParent, breakParent]);\n          var cursor = {\n            type: \"cursor\",\n            placeholder: Symbol(\"cursor\")\n          };\n          function join(sep, arr) {\n            const res = [];\n            for (let i = 0; i < arr.length; i++) {\n              if (i !== 0) {\n                res.push(sep);\n              }\n              res.push(arr[i]);\n            }\n            return concat(res);\n          }\n          function addAlignmentToDoc(doc, size, tabWidth) {\n            let aligned = doc;\n            if (size > 0) {\n              for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                aligned = indent(aligned);\n              }\n              aligned = align(size % tabWidth, aligned);\n              aligned = align(Number.NEGATIVE_INFINITY, aligned);\n            }\n            return aligned;\n          }\n          function label(label2, contents) {\n            return {\n              type: \"label\",\n              label: label2,\n              contents\n            };\n          }\n          module2.exports = {\n            concat,\n            join,\n            line,\n            softline,\n            hardline,\n            literalline,\n            group,\n            conditionalGroup,\n            fill,\n            lineSuffix,\n            lineSuffixBoundary,\n            cursor,\n            breakParent,\n            ifBreak,\n            trim,\n            indent,\n            indentIfBreak,\n            align,\n            addAlignmentToDoc,\n            markAsRoot,\n            dedentToRoot,\n            dedent,\n            hardlineWithoutBreakParent,\n            literallineWithoutBreakParent,\n            label\n          };\n        }\n      });\n      var require_end_of_line = __commonJS2({\n        \"src/common/end-of-line.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function guessEndOfLine(text) {\n            const index = text.indexOf(\"\\r\");\n            if (index >= 0) {\n              return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n            }\n            return \"lf\";\n          }\n          function convertEndOfLineToChars(value) {\n            switch (value) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return \"\\r\\n\";\n              default:\n                return \"\\n\";\n            }\n          }\n          function countEndOfLineChars(text, eol) {\n            let regex;\n            switch (eol) {\n              case \"\\n\":\n                regex = /\\n/g;\n                break;\n              case \"\\r\":\n                regex = /\\r/g;\n                break;\n              case \"\\r\\n\":\n                regex = /\\r\\n/g;\n                break;\n              default:\n                throw new Error('Unexpected \"eol\" '.concat(JSON.stringify(eol), \".\"));\n            }\n            const endOfLines = text.match(regex);\n            return endOfLines ? endOfLines.length : 0;\n          }\n          function normalizeEndOfLine(text) {\n            return text.replace(/\\r\\n?/g, \"\\n\");\n          }\n          module2.exports = {\n            guessEndOfLine,\n            convertEndOfLineToChars,\n            countEndOfLineChars,\n            normalizeEndOfLine\n          };\n        }\n      });\n      var require_get_last = __commonJS2({\n        \"src/utils/get-last.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = (arr) => arr[arr.length - 1];\n          module2.exports = getLast;\n        }\n      });\n      var require_string_width = __commonJS2({\n        \"vendors/string-width.js\"(exports2, module2) {\n          init_define_process();\n          var __create = Object.create;\n          var __defProp = Object.defineProperty;\n          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n          var __getOwnPropNames22 = Object.getOwnPropertyNames;\n          var __getProtoOf = Object.getPrototypeOf;\n          var __hasOwnProp = Object.prototype.hasOwnProperty;\n          var __commonJS22 = (cb, mod) => function __require() {\n            return mod || (0, cb[__getOwnPropNames22(cb)[0]])((mod = {\n              exports: {}\n            }).exports, mod), mod.exports;\n          };\n          var __export = (target, all) => {\n            for (var name in all)\n              __defProp(target, name, {\n                get: all[name],\n                enumerable: true\n              });\n          };\n          var __copyProps = (to, from, except, desc) => {\n            if (from && typeof from === \"object\" || typeof from === \"function\") {\n              for (let key of __getOwnPropNames22(from))\n                if (!__hasOwnProp.call(to, key) && key !== except)\n                  __defProp(to, key, {\n                    get: () => from[key],\n                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n                  });\n            }\n            return to;\n          };\n          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n            value: mod,\n            enumerable: true\n          }) : target, mod));\n          var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", {\n            value: true\n          }), mod);\n          var require_emoji_regex = __commonJS22({\n            \"node_modules/emoji-regex/index.js\"(exports3, module22) {\n              \"use strict\";\n              module22.exports = function() {\n                return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n              };\n            }\n          });\n          var string_width_exports = {};\n          __export(string_width_exports, {\n            default: () => stringWidth\n          });\n          module2.exports = __toCommonJS(string_width_exports);\n          function ansiRegex() {\n            let {\n              onlyFirst = false\n            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n            return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n          }\n          function stripAnsi(string) {\n            if (typeof string !== \"string\") {\n              throw new TypeError(\"Expected a `string`, got `\".concat(typeof string, \"`\"));\n            }\n            return string.replace(ansiRegex(), \"\");\n          }\n          function isFullwidthCodePoint(codePoint) {\n            if (!Number.isInteger(codePoint)) {\n              return false;\n            }\n            return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n          }\n          var import_emoji_regex = __toESM(require_emoji_regex(), 1);\n          function stringWidth(string) {\n            if (typeof string !== \"string\" || string.length === 0) {\n              return 0;\n            }\n            string = stripAnsi(string);\n            if (string.length === 0) {\n              return 0;\n            }\n            string = string.replace((0, import_emoji_regex.default)(), \"  \");\n            let width = 0;\n            for (let index = 0; index < string.length; index++) {\n              const codePoint = string.codePointAt(index);\n              if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n                continue;\n              }\n              if (codePoint >= 768 && codePoint <= 879) {\n                continue;\n              }\n              if (codePoint > 65535) {\n                index++;\n              }\n              width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n            }\n            return width;\n          }\n        }\n      });\n      var require_get_string_width = __commonJS2({\n        \"src/utils/get-string-width.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var stringWidth = require_string_width().default;\n          var notAsciiRegex = /[^\\x20-\\x7F]/;\n          function getStringWidth(text) {\n            if (!text) {\n              return 0;\n            }\n            if (!notAsciiRegex.test(text)) {\n              return text.length;\n            }\n            return stringWidth(text);\n          }\n          module2.exports = getStringWidth;\n        }\n      });\n      var require_doc_utils = __commonJS2({\n        \"src/document/doc-utils.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = require_get_last();\n          var {\n            literalline,\n            join\n          } = require_doc_builders();\n          var isConcat = (doc) => Array.isArray(doc) || doc && doc.type === \"concat\";\n          var getDocParts = (doc) => {\n            if (Array.isArray(doc)) {\n              return doc;\n            }\n            if (doc.type !== \"concat\" && doc.type !== \"fill\") {\n              throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n            }\n            return doc.parts;\n          };\n          var traverseDocOnExitStackMarker = {};\n          function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n            const docsStack = [doc];\n            while (docsStack.length > 0) {\n              const doc2 = docsStack.pop();\n              if (doc2 === traverseDocOnExitStackMarker) {\n                onExit(docsStack.pop());\n                continue;\n              }\n              if (onExit) {\n                docsStack.push(doc2, traverseDocOnExitStackMarker);\n              }\n              if (!onEnter || onEnter(doc2) !== false) {\n                if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                    docsStack.push(parts[i]);\n                  }\n                } else if (doc2.type === \"if-break\") {\n                  if (doc2.flatContents) {\n                    docsStack.push(doc2.flatContents);\n                  }\n                  if (doc2.breakContents) {\n                    docsStack.push(doc2.breakContents);\n                  }\n                } else if (doc2.type === \"group\" && doc2.expandedStates) {\n                  if (shouldTraverseConditionalGroups) {\n                    for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(doc2.expandedStates[i]);\n                    }\n                  } else {\n                    docsStack.push(doc2.contents);\n                  }\n                } else if (doc2.contents) {\n                  docsStack.push(doc2.contents);\n                }\n              }\n            }\n          }\n          function mapDoc(doc, cb) {\n            const mapped = /* @__PURE__ */ new Map();\n            return rec(doc);\n            function rec(doc2) {\n              if (mapped.has(doc2)) {\n                return mapped.get(doc2);\n              }\n              const result = process2(doc2);\n              mapped.set(doc2, result);\n              return result;\n            }\n            function process2(doc2) {\n              if (Array.isArray(doc2)) {\n                return cb(doc2.map(rec));\n              }\n              if (doc2.type === \"concat\" || doc2.type === \"fill\") {\n                const parts = doc2.parts.map(rec);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                }));\n              }\n              if (doc2.type === \"if-break\") {\n                const breakContents = doc2.breakContents && rec(doc2.breakContents);\n                const flatContents = doc2.flatContents && rec(doc2.flatContents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents,\n                  flatContents\n                }));\n              }\n              if (doc2.type === \"group\" && doc2.expandedStates) {\n                const expandedStates = doc2.expandedStates.map(rec);\n                const contents = expandedStates[0];\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents,\n                  expandedStates\n                }));\n              }\n              if (doc2.contents) {\n                const contents = rec(doc2.contents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents\n                }));\n              }\n              return cb(doc2);\n            }\n          }\n          function findInDoc(doc, fn, defaultValue) {\n            let result = defaultValue;\n            let hasStopped = false;\n            function findInDocOnEnterFn(doc2) {\n              const maybeResult = fn(doc2);\n              if (maybeResult !== void 0) {\n                hasStopped = true;\n                result = maybeResult;\n              }\n              if (hasStopped) {\n                return false;\n              }\n            }\n            traverseDoc(doc, findInDocOnEnterFn);\n            return result;\n          }\n          function willBreakFn(doc) {\n            if (doc.type === \"group\" && doc.break) {\n              return true;\n            }\n            if (doc.type === \"line\" && doc.hard) {\n              return true;\n            }\n            if (doc.type === \"break-parent\") {\n              return true;\n            }\n          }\n          function willBreak(doc) {\n            return findInDoc(doc, willBreakFn, false);\n          }\n          function breakParentGroup(groupStack) {\n            if (groupStack.length > 0) {\n              const parentGroup = getLast(groupStack);\n              if (!parentGroup.expandedStates && !parentGroup.break) {\n                parentGroup.break = \"propagated\";\n              }\n            }\n            return null;\n          }\n          function propagateBreaks(doc) {\n            const alreadyVisitedSet = /* @__PURE__ */ new Set();\n            const groupStack = [];\n            function propagateBreaksOnEnterFn(doc2) {\n              if (doc2.type === \"break-parent\") {\n                breakParentGroup(groupStack);\n              }\n              if (doc2.type === \"group\") {\n                groupStack.push(doc2);\n                if (alreadyVisitedSet.has(doc2)) {\n                  return false;\n                }\n                alreadyVisitedSet.add(doc2);\n              }\n            }\n            function propagateBreaksOnExitFn(doc2) {\n              if (doc2.type === \"group\") {\n                const group = groupStack.pop();\n                if (group.break) {\n                  breakParentGroup(groupStack);\n                }\n              }\n            }\n            traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n          }\n          function removeLinesFn(doc) {\n            if (doc.type === \"line\" && !doc.hard) {\n              return doc.soft ? \"\" : \" \";\n            }\n            if (doc.type === \"if-break\") {\n              return doc.flatContents || \"\";\n            }\n            return doc;\n          }\n          function removeLines(doc) {\n            return mapDoc(doc, removeLinesFn);\n          }\n          var isHardline = (doc, nextDoc) => doc && doc.type === \"line\" && doc.hard && nextDoc && nextDoc.type === \"break-parent\";\n          function stripDocTrailingHardlineFromDoc(doc) {\n            if (!doc) {\n              return doc;\n            }\n            if (isConcat(doc) || doc.type === \"fill\") {\n              const parts = getDocParts(doc);\n              while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                parts.length -= 2;\n              }\n              if (parts.length > 0) {\n                const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                parts[parts.length - 1] = lastPart;\n              }\n              return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n                parts\n              });\n            }\n            switch (doc.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\": {\n                const contents = stripDocTrailingHardlineFromDoc(doc.contents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  contents\n                });\n              }\n              case \"if-break\": {\n                const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);\n                const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  breakContents,\n                  flatContents\n                });\n              }\n            }\n            return doc;\n          }\n          function stripTrailingHardline(doc) {\n            return stripDocTrailingHardlineFromDoc(cleanDoc(doc));\n          }\n          function cleanDocFn(doc) {\n            switch (doc.type) {\n              case \"fill\":\n                if (doc.parts.every((part) => part === \"\")) {\n                  return \"\";\n                }\n                break;\n              case \"group\":\n                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n                  return \"\";\n                }\n                if (doc.contents.type === \"group\" && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n                  return doc.contents;\n                }\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!doc.contents) {\n                  return \"\";\n                }\n                break;\n              case \"if-break\":\n                if (!doc.flatContents && !doc.breakContents) {\n                  return \"\";\n                }\n                break;\n            }\n            if (!isConcat(doc)) {\n              return doc;\n            }\n            const parts = [];\n            for (const part of getDocParts(doc)) {\n              if (!part) {\n                continue;\n              }\n              const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n              if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                parts[parts.length - 1] += currentPart;\n              } else {\n                parts.push(currentPart);\n              }\n              parts.push(...restParts);\n            }\n            if (parts.length === 0) {\n              return \"\";\n            }\n            if (parts.length === 1) {\n              return parts[0];\n            }\n            return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n              parts\n            });\n          }\n          function cleanDoc(doc) {\n            return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n          }\n          function normalizeParts(parts) {\n            const newParts = [];\n            const restParts = parts.filter(Boolean);\n            while (restParts.length > 0) {\n              const part = restParts.shift();\n              if (!part) {\n                continue;\n              }\n              if (isConcat(part)) {\n                restParts.unshift(...getDocParts(part));\n                continue;\n              }\n              if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                newParts[newParts.length - 1] += part;\n                continue;\n              }\n              newParts.push(part);\n            }\n            return newParts;\n          }\n          function normalizeDoc(doc) {\n            return mapDoc(doc, (currentDoc) => {\n              if (Array.isArray(currentDoc)) {\n                return normalizeParts(currentDoc);\n              }\n              if (!currentDoc.parts) {\n                return currentDoc;\n              }\n              return Object.assign(Object.assign({}, currentDoc), {}, {\n                parts: normalizeParts(currentDoc.parts)\n              });\n            });\n          }\n          function replaceEndOfLine(doc) {\n            return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n          }\n          function replaceTextEndOfLine(text) {\n            let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n            return join(replacement, text.split(\"\\n\")).parts;\n          }\n          function canBreakFn(doc) {\n            if (doc.type === \"line\") {\n              return true;\n            }\n          }\n          function canBreak(doc) {\n            return findInDoc(doc, canBreakFn, false);\n          }\n          module2.exports = {\n            isConcat,\n            getDocParts,\n            willBreak,\n            traverseDoc,\n            findInDoc,\n            mapDoc,\n            propagateBreaks,\n            removeLines,\n            stripTrailingHardline,\n            normalizeParts,\n            normalizeDoc,\n            cleanDoc,\n            replaceTextEndOfLine,\n            replaceEndOfLine,\n            canBreak\n          };\n        }\n      });\n      var require_doc_printer = __commonJS2({\n        \"src/document/doc-printer.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            convertEndOfLineToChars\n          } = require_end_of_line();\n          var getLast = require_get_last();\n          var getStringWidth = require_get_string_width();\n          var {\n            fill,\n            cursor,\n            indent\n          } = require_doc_builders();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          var groupModeMap;\n          var MODE_BREAK = 1;\n          var MODE_FLAT = 2;\n          function rootIndent() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function makeIndent(ind, options) {\n            return generateInd(ind, {\n              type: \"indent\"\n            }, options);\n          }\n          function makeAlign(indent2, widthOrDoc, options) {\n            if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n              return indent2.root || rootIndent();\n            }\n            if (widthOrDoc < 0) {\n              return generateInd(indent2, {\n                type: \"dedent\"\n              }, options);\n            }\n            if (!widthOrDoc) {\n              return indent2;\n            }\n            if (widthOrDoc.type === \"root\") {\n              return Object.assign(Object.assign({}, indent2), {}, {\n                root: indent2\n              });\n            }\n            const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n            return generateInd(indent2, {\n              type: alignType,\n              n: widthOrDoc\n            }, options);\n          }\n          function generateInd(ind, newPart, options) {\n            const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n            let value = \"\";\n            let length = 0;\n            let lastTabs = 0;\n            let lastSpaces = 0;\n            for (const part of queue) {\n              switch (part.type) {\n                case \"indent\":\n                  flush();\n                  if (options.useTabs) {\n                    addTabs(1);\n                  } else {\n                    addSpaces(options.tabWidth);\n                  }\n                  break;\n                case \"stringAlign\":\n                  flush();\n                  value += part.n;\n                  length += part.n.length;\n                  break;\n                case \"numberAlign\":\n                  lastTabs += 1;\n                  lastSpaces += part.n;\n                  break;\n                default:\n                  throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n              }\n            }\n            flushSpaces();\n            return Object.assign(Object.assign({}, ind), {}, {\n              value,\n              length,\n              queue\n            });\n            function addTabs(count) {\n              value += \"\t\".repeat(count);\n              length += options.tabWidth * count;\n            }\n            function addSpaces(count) {\n              value += \" \".repeat(count);\n              length += count;\n            }\n            function flush() {\n              if (options.useTabs) {\n                flushTabs();\n              } else {\n                flushSpaces();\n              }\n            }\n            function flushTabs() {\n              if (lastTabs > 0) {\n                addTabs(lastTabs);\n              }\n              resetLast();\n            }\n            function flushSpaces() {\n              if (lastSpaces > 0) {\n                addSpaces(lastSpaces);\n              }\n              resetLast();\n            }\n            function resetLast() {\n              lastTabs = 0;\n              lastSpaces = 0;\n            }\n          }\n          function trim(out) {\n            if (out.length === 0) {\n              return 0;\n            }\n            let trimCount = 0;\n            while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n              trimCount += out.pop().length;\n            }\n            if (out.length > 0 && typeof getLast(out) === \"string\") {\n              const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n              trimCount += getLast(out).length - trimmed.length;\n              out[out.length - 1] = trimmed;\n            }\n            return trimCount;\n          }\n          function fits(next, restCommands, width, options, hasLineSuffix, mustBeFlat) {\n            let restIdx = restCommands.length;\n            const cmds = [next];\n            const out = [];\n            while (width >= 0) {\n              if (cmds.length === 0) {\n                if (restIdx === 0) {\n                  return true;\n                }\n                cmds.push(restCommands[restIdx - 1]);\n                restIdx--;\n                continue;\n              }\n              const [ind, mode, doc] = cmds.pop();\n              if (typeof doc === \"string\") {\n                out.push(doc);\n                width -= getStringWidth(doc);\n              } else if (isConcat(doc)) {\n                const parts = getDocParts(doc);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push([ind, mode, parts[i]]);\n                }\n              } else {\n                switch (doc.type) {\n                  case \"indent\":\n                    cmds.push([makeIndent(ind, options), mode, doc.contents]);\n                    break;\n                  case \"align\":\n                    cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n                    break;\n                  case \"trim\":\n                    width += trim(out);\n                    break;\n                  case \"group\": {\n                    if (mustBeFlat && doc.break) {\n                      return false;\n                    }\n                    const groupMode = doc.break ? MODE_BREAK : mode;\n                    cmds.push([ind, groupMode, doc.expandedStates && groupMode === MODE_BREAK ? getLast(doc.expandedStates) : doc.contents]);\n                    if (doc.id) {\n                      groupModeMap[doc.id] = groupMode;\n                    }\n                    break;\n                  }\n                  case \"fill\":\n                    for (let i = doc.parts.length - 1; i >= 0; i--) {\n                      cmds.push([ind, mode, doc.parts[i]]);\n                    }\n                    break;\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc.type === \"if-break\" ? doc.breakContents : doc.negate ? doc.contents : indent(doc.contents);\n                      if (breakContents) {\n                        cmds.push([ind, mode, breakContents]);\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc.type === \"if-break\" ? doc.flatContents : doc.negate ? indent(doc.contents) : doc.contents;\n                      if (flatContents) {\n                        cmds.push([ind, mode, flatContents]);\n                      }\n                    }\n                    break;\n                  }\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc.hard) {\n                          if (!doc.soft) {\n                            out.push(\" \");\n                            width -= 1;\n                          }\n                          break;\n                        }\n                        return true;\n                      case MODE_BREAK:\n                        return true;\n                    }\n                    break;\n                  case \"line-suffix\":\n                    hasLineSuffix = true;\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (hasLineSuffix) {\n                      return false;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push([ind, mode, doc.contents]);\n                    break;\n                }\n              }\n            }\n            return false;\n          }\n          function printDocToString(doc, options) {\n            groupModeMap = {};\n            const width = options.printWidth;\n            const newLine = convertEndOfLineToChars(options.endOfLine);\n            let pos = 0;\n            const cmds = [[rootIndent(), MODE_BREAK, doc]];\n            const out = [];\n            let shouldRemeasure = false;\n            let lineSuffix = [];\n            while (cmds.length > 0) {\n              const [ind, mode, doc2] = cmds.pop();\n              if (typeof doc2 === \"string\") {\n                const formatted = newLine !== \"\\n\" ? doc2.replace(/\\n/g, newLine) : doc2;\n                out.push(formatted);\n                pos += getStringWidth(formatted);\n              } else if (isConcat(doc2)) {\n                const parts = getDocParts(doc2);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push([ind, mode, parts[i]]);\n                }\n              } else {\n                switch (doc2.type) {\n                  case \"cursor\":\n                    out.push(cursor.placeholder);\n                    break;\n                  case \"indent\":\n                    cmds.push([makeIndent(ind, options), mode, doc2.contents]);\n                    break;\n                  case \"align\":\n                    cmds.push([makeAlign(ind, doc2.n, options), mode, doc2.contents]);\n                    break;\n                  case \"trim\":\n                    pos -= trim(out);\n                    break;\n                  case \"group\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!shouldRemeasure) {\n                          cmds.push([ind, doc2.break ? MODE_BREAK : MODE_FLAT, doc2.contents]);\n                          break;\n                        }\n                      case MODE_BREAK: {\n                        shouldRemeasure = false;\n                        const next = [ind, MODE_FLAT, doc2.contents];\n                        const rem = width - pos;\n                        const hasLineSuffix = lineSuffix.length > 0;\n                        if (!doc2.break && fits(next, cmds, rem, options, hasLineSuffix)) {\n                          cmds.push(next);\n                        } else {\n                          if (doc2.expandedStates) {\n                            const mostExpanded = getLast(doc2.expandedStates);\n                            if (doc2.break) {\n                              cmds.push([ind, MODE_BREAK, mostExpanded]);\n                              break;\n                            } else {\n                              for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                                if (i >= doc2.expandedStates.length) {\n                                  cmds.push([ind, MODE_BREAK, mostExpanded]);\n                                  break;\n                                } else {\n                                  const state = doc2.expandedStates[i];\n                                  const cmd = [ind, MODE_FLAT, state];\n                                  if (fits(cmd, cmds, rem, options, hasLineSuffix)) {\n                                    cmds.push(cmd);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          } else {\n                            cmds.push([ind, MODE_BREAK, doc2.contents]);\n                          }\n                        }\n                        break;\n                      }\n                    }\n                    if (doc2.id) {\n                      groupModeMap[doc2.id] = getLast(cmds)[1];\n                    }\n                    break;\n                  case \"fill\": {\n                    const rem = width - pos;\n                    const {\n                      parts\n                    } = doc2;\n                    if (parts.length === 0) {\n                      break;\n                    }\n                    const [content, whitespace] = parts;\n                    const contentFlatCmd = [ind, MODE_FLAT, content];\n                    const contentBreakCmd = [ind, MODE_BREAK, content];\n                    const contentFits = fits(contentFlatCmd, [], rem, options, lineSuffix.length > 0, true);\n                    if (parts.length === 1) {\n                      if (contentFits) {\n                        cmds.push(contentFlatCmd);\n                      } else {\n                        cmds.push(contentBreakCmd);\n                      }\n                      break;\n                    }\n                    const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n                    const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n                    if (parts.length === 2) {\n                      if (contentFits) {\n                        cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    parts.splice(0, 2);\n                    const remainingCmd = [ind, mode, fill(parts)];\n                    const secondContent = parts[0];\n                    const firstAndSecondContentFlatCmd = [ind, MODE_FLAT, [content, whitespace, secondContent]];\n                    const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, options, lineSuffix.length > 0, true);\n                    if (firstAndSecondContentFits) {\n                      cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                    } else if (contentFits) {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                    } else {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                    }\n                    break;\n                  }\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc2.type === \"if-break\" ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n                      if (breakContents) {\n                        cmds.push([ind, mode, breakContents]);\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc2.type === \"if-break\" ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n                      if (flatContents) {\n                        cmds.push([ind, mode, flatContents]);\n                      }\n                    }\n                    break;\n                  }\n                  case \"line-suffix\":\n                    lineSuffix.push([ind, mode, doc2.contents]);\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (lineSuffix.length > 0) {\n                      cmds.push([ind, mode, {\n                        type: \"line\",\n                        hard: true\n                      }]);\n                    }\n                    break;\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc2.hard) {\n                          if (!doc2.soft) {\n                            out.push(\" \");\n                            pos += 1;\n                          }\n                          break;\n                        } else {\n                          shouldRemeasure = true;\n                        }\n                      case MODE_BREAK:\n                        if (lineSuffix.length > 0) {\n                          cmds.push([ind, mode, doc2], ...lineSuffix.reverse());\n                          lineSuffix = [];\n                          break;\n                        }\n                        if (doc2.literal) {\n                          if (ind.root) {\n                            out.push(newLine, ind.root.value);\n                            pos = ind.root.length;\n                          } else {\n                            out.push(newLine);\n                            pos = 0;\n                          }\n                        } else {\n                          pos -= trim(out);\n                          out.push(newLine + ind.value);\n                          pos = ind.length;\n                        }\n                        break;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push([ind, mode, doc2.contents]);\n                    break;\n                  default:\n                }\n              }\n              if (cmds.length === 0 && lineSuffix.length > 0) {\n                cmds.push(...lineSuffix.reverse());\n                lineSuffix = [];\n              }\n            }\n            const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n            if (cursorPlaceholderIndex !== -1) {\n              const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n              const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n              const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n              const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n              return {\n                formatted: beforeCursor + aroundCursor + afterCursor,\n                cursorNodeStart: beforeCursor.length,\n                cursorNodeText: aroundCursor\n              };\n            }\n            return {\n              formatted: out.join(\"\")\n            };\n          }\n          module2.exports = {\n            printDocToString\n          };\n        }\n      });\n      var require_doc_debug = __commonJS2({\n        \"src/document/doc-debug.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          function flattenDoc(doc) {\n            if (!doc) {\n              return \"\";\n            }\n            if (isConcat(doc)) {\n              const res = [];\n              for (const part of getDocParts(doc)) {\n                if (isConcat(part)) {\n                  res.push(...flattenDoc(part).parts);\n                } else {\n                  const flattened = flattenDoc(part);\n                  if (flattened !== \"\") {\n                    res.push(flattened);\n                  }\n                }\n              }\n              return {\n                type: \"concat\",\n                parts: res\n              };\n            }\n            if (doc.type === \"if-break\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                breakContents: flattenDoc(doc.breakContents),\n                flatContents: flattenDoc(doc.flatContents)\n              });\n            }\n            if (doc.type === \"group\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents),\n                expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc)\n              });\n            }\n            if (doc.type === \"fill\") {\n              return {\n                type: \"fill\",\n                parts: doc.parts.map(flattenDoc)\n              };\n            }\n            if (doc.contents) {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents)\n              });\n            }\n            return doc;\n          }\n          function printDocToDebug(doc) {\n            const printedSymbols = /* @__PURE__ */ Object.create(null);\n            const usedKeysForSymbols = /* @__PURE__ */ new Set();\n            return printDoc(flattenDoc(doc));\n            function printDoc(doc2, index, parentParts) {\n              if (typeof doc2 === \"string\") {\n                return JSON.stringify(doc2);\n              }\n              if (isConcat(doc2)) {\n                const printed = getDocParts(doc2).map(printDoc).filter(Boolean);\n                return printed.length === 1 ? printed[0] : \"[\".concat(printed.join(\", \"), \"]\");\n              }\n              if (doc2.type === \"line\") {\n                const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                if (doc2.literal) {\n                  return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                }\n                if (doc2.hard) {\n                  return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                }\n                if (doc2.soft) {\n                  return \"softline\";\n                }\n                return \"line\";\n              }\n              if (doc2.type === \"break-parent\") {\n                const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                return afterHardline ? void 0 : \"breakParent\";\n              }\n              if (doc2.type === \"trim\") {\n                return \"trim\";\n              }\n              if (doc2.type === \"indent\") {\n                return \"indent(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"align\") {\n                return doc2.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc2.contents) + \")\" : doc2.n < 0 ? \"dedent(\" + printDoc(doc2.contents) + \")\" : doc2.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc2.contents) + \")\" : \"align(\" + JSON.stringify(doc2.n) + \", \" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"if-break\") {\n                return \"ifBreak(\" + printDoc(doc2.breakContents) + (doc2.flatContents ? \", \" + printDoc(doc2.flatContents) : \"\") + (doc2.groupId ? (!doc2.flatContents ? ', \"\"' : \"\") + \", { groupId: \".concat(printGroupId(doc2.groupId), \" }\") : \"\") + \")\";\n              }\n              if (doc2.type === \"indent-if-break\") {\n                const optionsParts = [];\n                if (doc2.negate) {\n                  optionsParts.push(\"negate: true\");\n                }\n                if (doc2.groupId) {\n                  optionsParts.push(\"groupId: \".concat(printGroupId(doc2.groupId)));\n                }\n                const options = optionsParts.length > 0 ? \", { \".concat(optionsParts.join(\", \"), \" }\") : \"\";\n                return \"indentIfBreak(\".concat(printDoc(doc2.contents)).concat(options, \")\");\n              }\n              if (doc2.type === \"group\") {\n                const optionsParts = [];\n                if (doc2.break && doc2.break !== \"propagated\") {\n                  optionsParts.push(\"shouldBreak: true\");\n                }\n                if (doc2.id) {\n                  optionsParts.push(\"id: \".concat(printGroupId(doc2.id)));\n                }\n                const options = optionsParts.length > 0 ? \", { \".concat(optionsParts.join(\", \"), \" }\") : \"\";\n                if (doc2.expandedStates) {\n                  return \"conditionalGroup([\".concat(doc2.expandedStates.map((part) => printDoc(part)).join(\",\"), \"]\").concat(options, \")\");\n                }\n                return \"group(\".concat(printDoc(doc2.contents)).concat(options, \")\");\n              }\n              if (doc2.type === \"fill\") {\n                return \"fill([\".concat(doc2.parts.map((part) => printDoc(part)).join(\", \"), \"])\");\n              }\n              if (doc2.type === \"line-suffix\") {\n                return \"lineSuffix(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"line-suffix-boundary\") {\n                return \"lineSuffixBoundary\";\n              }\n              if (doc2.type === \"label\") {\n                return \"label(\".concat(JSON.stringify(doc2.label), \", \").concat(printDoc(doc2.contents), \")\");\n              }\n              throw new Error(\"Unknown doc type \" + doc2.type);\n            }\n            function printGroupId(id) {\n              if (typeof id !== \"symbol\") {\n                return JSON.stringify(String(id));\n              }\n              if (id in printedSymbols) {\n                return printedSymbols[id];\n              }\n              const prefix = String(id).slice(7, -1) || \"symbol\";\n              for (let counter = 0; ; counter++) {\n                const key = prefix + (counter > 0 ? \" #\".concat(counter) : \"\");\n                if (!usedKeysForSymbols.has(key)) {\n                  usedKeysForSymbols.add(key);\n                  return printedSymbols[id] = \"Symbol.for(\".concat(JSON.stringify(key), \")\");\n                }\n              }\n            }\n          }\n          module2.exports = {\n            printDocToDebug\n          };\n        }\n      });\n      init_define_process();\n      module.exports = {\n        builders: require_doc_builders(),\n        printer: require_doc_printer(),\n        utils: require_doc_utils(),\n        debug: require_doc_debug()\n      };\n    }\n  });\n  \"use strict\";\n  return require_doc();\n});", "export * from \"./libs/printer\";\nexport * from \"./libs/prettier-plugin-latex\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * A [Prettier](https://prettier.io/) plugin for formatting and pretty-printing LaTeX source code.\n *\n * ## When should I use this?\n *\n * If you want to construct a `Prettier` instance that has LaTeX parsing abilities.\n * \n * You should probably use the `prettier-plugin-latex` package instead of directly accessing this package.\n */\n", "import { builders } from \"prettier/doc\";\nimport type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Computes the environment name, start/end, and args.\n * E.g., for \"\\begin{x}abc\\end{x}\", it returns\n * ```\n * {\n *  envName: \"x\",\n *  start: \"\\\\begin{x}\",\n *  end: \"\\\\end{x}\",\n * }\n * ```\n *\n * @param {*} node\n * @returns\n */\nexport function formatEnvSurround(node: Ast.Environment) {\n    const env = printRaw(node.env);\n\n    return {\n        envName: env,\n        start: ESCAPE + \"begin{\" + env + \"}\",\n        end: ESCAPE + \"end{\" + env + \"}\",\n    };\n}\n\n/**\n * Determine if `elm` is a line type (softline/hardline/etc). If `elm` is an\n * array or a concat, the first element is checked.\n */\nfunction isLineType(elm: Doc): boolean {\n    if (elm == null || typeof elm === \"string\") {\n        return false;\n    }\n    if (Array.isArray(elm)) {\n        return isLineType(elm[0]);\n    }\n    if (elm.type === \"concat\") {\n        return isLineType(elm.parts);\n    }\n    return elm.type === \"line\";\n}\n\n/**\n * Join an array with `softline`. However, if a `line` is\n * found, do not insert an additional softline. For example\n * `[a, b, c]` -> `[a, softline, b, softline, c]`\n *\n * but\n *\n * `[a, line, b, c]` -> `[a, line, b, softline, c]`\n *\n * @param {*} arr\n * @returns\n */\nexport function joinWithSoftline(arr: Doc[]) {\n    if (arr.length === 0 || arr.length === 1) {\n        return arr;\n    }\n    const ret = [arr[0]];\n    for (let i = 1; i < arr.length; i++) {\n        const prevNode = arr[i - 1];\n        const nextNode = arr[i];\n        if (!isLineType(prevNode) && !isLineType(nextNode)) {\n            ret.push(softline);\n        }\n        ret.push(nextNode);\n    }\n    return ret;\n}\n\nexport function getNodeInfo(\n    node: any,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap }\n): {\n    renderInfo: Record<string, any>;\n    renderCache?: object;\n    previousNode?: Ast.Node;\n    nextNode?: Ast.Node;\n    referenceMap?: ReferenceMap;\n} {\n    const renderInfo = node._renderInfo || {};\n    const previousNode =\n        options.referenceMap && options.referenceMap.getPreviousNode(node);\n    const nextNode =\n        options.referenceMap && options.referenceMap.getNextNode(node);\n    const renderCache =\n        options.referenceMap && options.referenceMap.getRenderCache(node);\n    // It's useful to know whether we're the start or end node in an array,\n    // so compute this information.\n    return {\n        renderInfo,\n        renderCache,\n        previousNode,\n        nextNode,\n        referenceMap: options.referenceMap,\n    };\n}\n\nexport const ESCAPE = \"\\\\\";\n\n// Commands to build the prettier syntax tree\nexport const {\n    group,\n    fill,\n    ifBreak,\n    line,\n    softline,\n    hardline,\n    lineSuffix,\n    lineSuffixBoundary,\n    breakParent,\n    indent,\n    markAsRoot,\n    join,\n} = builders;\n\n/**\n * Given an array of nodes and the corresponding printed versions, prepares\n * a final Doc array. This function does things like ensures there are `hardlines`\n * around environments and that there aren't excess hardlines at the start or end.\n * It also unwraps `inParMode` macro contents.\n *\n * @export\n * @param {Ast.Node[]} nodes\n * @param {Doc[]} docArray\n * @param {*} options\n * @returns {Doc[]}\n */\nexport function formatDocArray(\n    nodes: Ast.Node[],\n    docArray: Doc[],\n    options: any\n): Doc[] {\n    const ret: Doc[] = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n        const rawNode = nodes[i];\n        const printedNode = docArray[i];\n        const { renderInfo, referenceMap, previousNode, nextNode } =\n            getNodeInfo(rawNode, options);\n        const renderCache =\n            referenceMap && referenceMap.getRenderCache(rawNode);\n\n        switch (rawNode.type) {\n            case \"comment\":\n                // Comments don't insert hardlines themselves; they depend on appropriate\n                // hardlines being inserted here.\n\n                // This comment printer inserts hardlines after comments, so do not insert\n                // a hardline before a comment if there is a comment right before.\n                if (\n                    !rawNode.sameline &&\n                    previousNode &&\n                    !match.comment(previousNode) &&\n                    !match.parbreak(previousNode)\n                ) {\n                    ret.push(hardline);\n                }\n                ret.push(printedNode);\n                if (nextNode && !rawNode.suffixParbreak) {\n                    ret.push(hardline);\n                }\n                break;\n            case \"environment\":\n            case \"displaymath\":\n            case \"mathenv\":\n                // Environments always start on a new line (unless they are the first\n                // item). Peek to see if there is a newline inserted already.\n                if (previousNode && previousNode?.type !== \"parbreak\") {\n                    if (ret[ret.length - 1] === line) {\n                        // A preceding `line` should be converted into a `hardline`.\n                        // Remove the line so a hardline can be added\n                        ret.pop();\n                    }\n                    if (ret[ret.length - 1] !== hardline) {\n                        ret.push(hardline);\n                    }\n                }\n                ret.push(printedNode);\n                // If an environment is followed by whitespace, replace it with a hardline\n                // instead\n                if (nextNode?.type === \"whitespace\") {\n                    ret.push(hardline);\n                    i++;\n                }\n\n                break;\n            case \"macro\":\n                if (renderInfo.breakBefore || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be preceded by a hardline\n                    if (previousNode) {\n                        if (\n                            ret[ret.length - 1] === line ||\n                            ret[ret.length - 1] === hardline\n                        ) {\n                            // We may be replacing a hardline here for no reason. However,\n                            // if there is already a hardline, we don't want to continue\n                            // and accidentally add too many linebreaks\n                            ret.pop();\n                            ret.push(hardline);\n                        } else if (\n                            !match.comment(previousNode) &&\n                            !match.parbreak(previousNode)\n                        ) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                // Macros marked as `inParMode` should be unwrapped\n                // unless they have a hanging indent, in which case the macro\n                // has already be wrapped in an `indent` block\n                if (\n                    renderInfo.inParMode &&\n                    !renderInfo.hangingIndent &&\n                    renderCache\n                ) {\n                    ret.push(\n                        (renderCache as any).content,\n                        ...((renderCache as any).rawArgs || [])\n                    );\n                } else {\n                    ret.push(printedNode);\n                }\n                if (renderInfo.breakAfter || renderInfo.breakAround) {\n                    // Commands like \\section{} should always be followed by a hardline\n                    if (nextNode) {\n                        if (match.whitespace(nextNode)) {\n                            ret.push(hardline);\n                            i++;\n                        } else if (match.parbreak(nextNode)) {\n                            // If the next node is a parbreak, it will insert its own newline\n                        } else if (!match.comment(nextNode)) {\n                            ret.push(hardline);\n                        }\n                    }\n                }\n                break;\n            case \"parbreak\":\n                ret.push(hardline, hardline);\n                break;\n            default:\n                ret.push(printedNode);\n                break;\n        }\n    }\n\n    return ret;\n}\n", "export function zip<T, U>(array1: T[], array2: U[]): [T, U][] {\n    const ret: [T, U][] = [];\n    const len = Math.min(array1.length, array2.length);\n    for (let i = 0; i < len; i++) {\n        ret.push([array1[i], array2[i]]);\n    }\n    return ret;\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, ESCAPE, indent, group } from \"./common\";\nimport { zip } from \"../zip\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport function printMacro(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Macro;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content =\n        (node.escapeToken != null ? node.escapeToken : ESCAPE) + node.content;\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n\n    // Some of the arguments want to be printed \"inline\".\n    // We loop through the arguments and unwrap the inline ones.\n    const rawArgs = [];\n    for (const [arg, printedArg] of zip(node.args || [], args)) {\n        const renderCache = referenceMap && referenceMap.getRenderCache(arg);\n        if (renderInfo.inParMode && renderCache) {\n            rawArgs.push(...(renderCache as any[]));\n        } else {\n            rawArgs.push(printedArg);\n        }\n    }\n\n    if (referenceMap) {\n        referenceMap.setRenderCache(node, { rawArgs, content });\n    }\n\n    if (renderInfo.hangingIndent) {\n        return indent(fill([content, ...rawArgs]));\n    }\n\n    return group([content, ...rawArgs]);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    formatDocArray,\n    hardline,\n    join,\n    ifBreak,\n    breakParent,\n    line,\n    group,\n    indent,\n    softline,\n    fill,\n} from \"./common\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parsePgfkeys } from \"@unified-latex/unified-latex-util-pgfkeys\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nexport function printArgument(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Argument;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    // We can return early for empty arguments (this is common for omitted optional arguments)\n    if (\n        node.openMark === \"\" &&\n        node.closeMark === \"\" &&\n        node.content.length === 0\n    ) {\n        return [];\n    }\n\n    const openMark = node.openMark;\n    const closeMark = node.closeMark;\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n\n    // if the last item is a comment, we need to insert a hardline\n    if (match.comment(node.content[node.content.length - 1])) {\n        content.push(hardline);\n    }\n\n    let rawRet: Doc[] = [openMark, fill(content), closeMark];\n    if (renderInfo.inParMode) {\n        // In paragraph node, arguments should flow just like text\n        rawRet = [openMark, ...content, closeMark];\n    }\n    if (referenceMap) {\n        // Save the raw rendered data in case a renderer higher up\n        // wants to unwrap it\n        referenceMap.setRenderCache(node, rawRet);\n    }\n\n    if (path.getParentNode()) {\n        const parentNode = path.getParentNode();\n        const { renderInfo: parentRenderInfo } = getNodeInfo(\n            parentNode,\n            options\n        );\n        if (parentRenderInfo.pgfkeysArgs) {\n            const leadingComment =\n                node.content.length > 0 &&\n                match.comment(node.content[0]) &&\n                node.content[0].sameline\n                    ? node.content[0]\n                    : null;\n            const content = leadingComment\n                ? node.content.slice(1)\n                : node.content;\n            trim(content);\n            return printPgfkeysArgument(content, {\n                openMark: node.openMark,\n                closeMark: node.closeMark,\n                leadingComment,\n            });\n        }\n    }\n\n    return rawRet;\n}\n\n/**\n * Format a sequence of Pgfkeys key-value pairs. `nodes` will be parsed\n * by a grammar defining Pgfkeys\n *\n * @param {Ast.Node[]} nodes\n * @param {{ openMark: string; closeMark: string; leadingComment: Ast.Comment | null }} braces - A `leadingComment` is a comment that appears as the first item in the environment (e.g. `\\pgfkeys{%comment\\na,b,c}`)\n * @returns {Doc}\n */\nfunction printPgfkeysArgument(\n    nodes: Ast.Node[],\n    braces: {\n        openMark: string;\n        closeMark: string;\n        leadingComment: Ast.Comment | null | undefined;\n    }\n): Doc {\n    const parsed = parsePgfkeys(nodes);\n\n    const content: Doc[] = [];\n    for (const part of parsed) {\n        const isLastItem = part === parsed[parsed.length - 1];\n\n        if (part.itemParts) {\n            // parts are printed using `printRaw`, `hardline` is used in place\n            // of \"\\n\"\n            const parts = part.itemParts.map((node) =>\n                printRaw(node, { asArray: true }).map((token) =>\n                    token === linebreak ? hardline : token\n                )\n            );\n            const row = join(\"=\", parts);\n            content.push(row);\n            if (part.trailingComma) {\n                content.push(\",\");\n            }\n        }\n        if (part.trailingComment) {\n            const leadingContent: Doc[] = part.itemParts ? [\" \"] : [];\n            if (part.leadingParbreak) {\n                // We preserve parbreaks before comments, so if we have\n                // one, insert an extra hardline\n                leadingContent.push(hardline);\n            }\n\n            content.push(\n                ...leadingContent,\n                // We're carefully and manually controlling the newlines,\n                // so print the comment directly without any newlines\n                \"%\",\n                part.trailingComment.content,\n                breakParent\n            );\n        }\n\n        if (!isLastItem) {\n            content.push(line);\n        }\n    }\n\n    let leadingComment: Doc[] = [\"\"];\n    if (braces.leadingComment) {\n        if (braces.leadingComment.leadingWhitespace) {\n            leadingComment.push(\" \");\n        }\n        leadingComment.push(\"%\" + braces.leadingComment.content, breakParent);\n    }\n\n    return group([\n        braces.openMark,\n        ...leadingComment,\n        // If there is no content, we don't want to push an extra `softline`.\n        // This matters because the braces group could still be broken by `leadingComment`\n        content.length > 0 ? indent([softline, ...content]) : \"\",\n        softline,\n        braces.closeMark,\n    ]);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport { getNodeInfo, fill, formatDocArray } from \"./common\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns true if a `\\documentclass` macro is detected,\n * which would indicate that the node list contains the preamble.\n *\n * @param {[object]} nodes\n */\nexport function hasPreambleCode(nodes: Ast.Node[]) {\n    return nodes.some((node) => match.macro(node, \"documentclass\"));\n}\n\nexport function printRoot(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Root;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const content = path.map(print, \"content\");\n    const rawContent = formatDocArray(node.content, content, options);\n\n    const concatFunction = hasPreambleCode(node.content) ? (x: any) => x : fill;\n    return concatFunction(rawContent);\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nexport function printComment(\n    path: PrettierTypes.AstPath,\n    _print: PrettierTypes.RecursivePrintFunc,\n    _options: any\n): Doc {\n    const node = path.getNode() as Ast.Comment;\n\n    // If a comment is on the same line as other content and it has leading whitespace,\n    // add a single whitespace token.\n    let leadingWhitespace = \"\";\n    if (node.leadingWhitespace && node.sameline) {\n        leadingWhitespace = \" \";\n    }\n\n    const content: Doc[] = [leadingWhitespace, \"%\" + printRaw(node.content)];\n    return content;\n}\n", "import type { Doc } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    hardline,\n    line,\n    indent,\n    ESCAPE,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\n\nexport function printInlineMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    // Since `$$` starts display math mode (in plain TeX),\n    // an empty inline math environment must be printed as `$ $`.\n    // We special case this.\n    if (node.content.length === 0) {\n        // We won't allow an empty math environment to be broken\n        return [\"$\", \" \", \"$\"];\n    }\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If the last node is a comment, we need a linebreak before the closing `$`\n    if (node.content[node.content.length - 1].type === \"comment\") {\n        content.push(hardline);\n    }\n\n    return fill([\"$\", ...content, \"$\"]);\n}\n\nexport function printDisplayMath(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.InlineMath;\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    content = joinWithSoftline(content);\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    const bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        ESCAPE + \"[\",\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        ESCAPE + \"]\",\n    ];\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\nimport {\n    getNodeInfo,\n    softline,\n    fill,\n    indent,\n    hardline,\n    line,\n    ESCAPE,\n    formatEnvSurround,\n    joinWithSoftline,\n    formatDocArray,\n} from \"./common\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\nexport function printVerbatimEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.VerbatimEnvironment;\n\n    const env = formatEnvSurround(node as any);\n\n    return [env.start, node.content, env.end];\n}\n\nexport function printEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    let content = path.map(print, \"content\");\n    content = formatDocArray(node.content, content, options);\n    if (renderInfo.inMathMode) {\n        content = joinWithSoftline(content);\n    }\n\n    // If we start with a comment on the same line as the environment\n    // We should not insert a newline at the start of the environment body\n    let bodyStartToken: PrettierTypes.Doc[] = [hardline];\n    if (\n        node.content.length === 0 ||\n        (node.content[0].type === \"comment\" && node.content[0].sameline)\n    ) {\n        bodyStartToken.pop();\n    }\n\n    return [\n        env.start,\n        ...args,\n        indent(fill(bodyStartToken.concat(content))),\n        hardline,\n        env.end,\n    ];\n}\n\nexport function printAlignedEnvironment(\n    path: PrettierTypes.AstPath,\n    print: PrettierTypes.RecursivePrintFunc,\n    options: any\n): Doc {\n    const node = path.getNode() as Ast.Environment;\n    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(\n        node,\n        options\n    );\n\n    const args = node.args ? path.map(print, \"args\" as any) : [];\n    const env = formatEnvSurround(node);\n\n    // If an aligned environment starts with a same-line comment, we want\n    // to ignore it. It will be printed by the environment itself.\n    const leadingComment =\n        node.content[0] &&\n        node.content[0].type === \"comment\" &&\n        node.content[0].sameline\n            ? node.content[0]\n            : null;\n\n    const { rows, rowSeps, trailingComments } = formatAlignedContent(\n        leadingComment ? node.content.slice(1) : node.content\n    );\n\n    const content = [];\n    for (let i = 0; i < rows.length; i++) {\n        const row = rows[i];\n        const rowSep = rowSeps[i];\n        const trailingComment = trailingComments[i];\n\n        // A row has\n        // 1) Content\n        // 2) (optional) rowSep (e.g., `\\\\`)\n        // 3) (optional) comment\n        // We want there to be exactly one space before the rowsep and exactly one space\n        // before any comment.\n        content.push(row);\n        if (rowSep) {\n            content.push(printRaw(rowSep));\n        }\n        if (rowSep && trailingComment) {\n            content.push(\" \");\n        }\n        if (trailingComment) {\n            content.push([\"%\", printRaw(trailingComment.content)]);\n        }\n        if (rowSep || trailingComment) {\n            content.push(hardline);\n        }\n    }\n    // Make sure the last item is not a `hardline`.\n    if (content[content.length - 1] === hardline) {\n        content.pop();\n    }\n\n    if (leadingComment) {\n        content.unshift(\n            leadingComment.leadingWhitespace ? \" \" : \"\",\n            \"%\" + printRaw(leadingComment.content),\n            hardline\n        );\n        return [env.start, ...args, indent(content), hardline, env.end];\n    }\n    return [\n        env.start,\n        ...args,\n        indent([hardline, ...content]),\n        hardline,\n        env.end,\n    ];\n}\n\n/**\n * Formats the content of an aligned/tabular environment's content.\n * Ensures the \"&\" delimiters all line up.\n *\n * @export\n * @param {[object]} nodes\n * @returns {{rows: [string], rowSeps: [object]}}\n */\nexport function formatAlignedContent(nodes: Ast.Node[]) {\n    function getSpace(len = 1) {\n        return \" \".repeat(len);\n    }\n\n    const rows = parseAlignEnvironment(nodes as any);\n    // Find the number of columns\n    const numCols = Math.max(...rows.map((r) => r.cells.length));\n    const rowSeps = rows.map(({ rowSep }) => printRaw(rowSep || []));\n    const trailingComments = rows.map(({ trailingComment }) => trailingComment);\n\n    // Get the widths of each column.\n    // Column widths will be the width of column contents plus the width\n    // of the separator. This way, even multi-character separators\n    // can be accommodated when rendering.\n    const renderedRows = rows.map(({ cells, colSeps }) => ({\n        cells: cells.map((nodes) => {\n            trim(nodes);\n\n            return printRaw(nodes);\n        }),\n        seps: colSeps.map((nodes) => printRaw(nodes)),\n    }));\n    const colWidths: number[] = [];\n    for (let i = 0; i < numCols; i++) {\n        colWidths.push(\n            Math.max(\n                ...renderedRows.map(\n                    ({ cells, seps }) =>\n                        ((cells[i] || \"\") + (seps[i] || \"\")).length\n                )\n            )\n        );\n    }\n\n    const joinedRows = renderedRows.map(({ cells, seps }) => {\n        if (cells.length === 1 && cells[0] === \"\") {\n            return \"\";\n        }\n        let ret = \"\";\n        for (let i = 0; i < cells.length; i++) {\n            // There are at least as many cells as there are `seps`. Possibly one extra\n            const width = colWidths[i] - (seps[i] || \"\").length;\n\n            // Insert a space at the start so we don't run into the prior separator.\n            // We'll trim this off in the end, in case it's not needed.\n            ret +=\n                (i === 0 ? \"\" : \" \") +\n                cells[i] +\n                getSpace(width - cells[i].length + 1) +\n                (seps[i] || \"\");\n        }\n        return ret;\n    });\n\n    return { rows: joinedRows, rowSeps, trailingComments };\n}\n", "import type { Doc } from \"prettier\";\nimport * as PrettierTypes from \"./prettier-types\";\n\nimport { hardline, line, ESCAPE, getNodeInfo } from \"./common\";\nimport { printMacro } from \"./macro\";\nimport { printArgument } from \"./argument\";\nimport { printRoot } from \"./root\";\nimport { printComment } from \"./comment\";\nimport { printInlineMath, printDisplayMath } from \"./math\";\nimport {\n    printVerbatimEnvironment,\n    printEnvironment,\n    printAlignedEnvironment,\n} from \"./environment\";\nimport {\n    linebreak,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-print-raw\";\nimport { ReferenceMap } from \"../reference-map\";\n\nexport function printLatexAst(\n    path: PrettierTypes.AstPath,\n    options: PrettierTypes.Options & { referenceMap?: ReferenceMap },\n    print: PrettierTypes.RecursivePrintFunc\n): Doc {\n    const node = path.getValue();\n    const { renderInfo } = getNodeInfo(node, options);\n\n    if (node == null) {\n        return node;\n    }\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    switch (node.type) {\n        case \"root\":\n            // Create the ReferenceMap from the root node, so that\n            // it can traverse the entire AST\n            if (options.referenceMap) {\n                console.warn(\n                    \"Processing root node, but ReferenceMap already exists. Are there multiple nodes of type 'root'?\"\n                );\n            }\n            options.referenceMap = new ReferenceMap(node);\n            return printRoot(path, print, options);\n        case \"argument\":\n            return printArgument(path, print, options);\n        case \"comment\":\n            return printComment(path, print, options);\n        case \"environment\":\n        case \"mathenv\":\n            if (renderInfo.alignContent) {\n                return printAlignedEnvironment(path, print, options);\n            }\n            return printEnvironment(path, print, options);\n        case \"displaymath\":\n            return printDisplayMath(path, print, options);\n        case \"group\":\n            // When we print a group, we are conservative and do a raw print of its contents.\n            // However, we want to use `linebreak`s instead of literal `\\n` tokens.\n            const content = printRaw(node.content, {\n                asArray: true,\n            }).map((token) => (token === linebreak ? hardline : token));\n            return [\"{\", ...content, \"}\"];\n        case \"inlinemath\":\n            return printInlineMath(path, print, options);\n        case \"macro\":\n            return printMacro(path, print, options);\n        case \"parbreak\":\n            return [hardline, hardline];\n        case \"string\":\n            return node.content;\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                printRaw(node.content),\n                node.escape,\n            ];\n        case \"verbatim\":\n            return printVerbatimEnvironment(path, print, options);\n        case \"whitespace\":\n            return line;\n        default:\n            console.warn(\"Printing unknown type\", node);\n            return printRaw(node);\n    }\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Generate a data structure that can be queried\n * for the next/previous node. This allows for \"peeking\"\n * during the rendering process.\n *\n * @class ReferenceMap\n */\nexport class ReferenceMap {\n    ast: Ast.Ast;\n    map: Map<\n        Ast.Ast,\n        { previous?: Ast.Ast; next?: Ast.Ast; renderCache?: any }\n    >;\n\n    constructor(ast: Ast.Ast) {\n        this.ast = ast;\n        this.map = new Map();\n        visit(\n            this.ast,\n            (nodeList) => {\n                for (let i = 0; i < nodeList.length; i++) {\n                    this.map.set(nodeList[i], {\n                        previous: nodeList[i - 1],\n                        next: nodeList[i + 1],\n                    });\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    }\n\n    /**\n     * Associate render-specific data with this node. This data\n     * will be overwritten if `setRenderCache` is called twice.\n     *\n     * @param {Ast.Ast} node\n     * @param {*} data\n     * @memberof ReferenceMap\n     */\n    setRenderCache(node: any, data: any): void {\n        const currData = this.map.get(node) || {};\n        this.map.set(node, { ...currData, renderCache: data });\n    }\n\n    /**\n     * Retrieve data associated with `node` via `setRenderCache`\n     *\n     * @param {Ast.Ast} node\n     * @returns {(object | undefined)}\n     * @memberof ReferenceMap\n     */\n    getRenderCache(node: any): object | any[] | undefined {\n        return this.map.get(node)?.renderCache;\n    }\n\n    getPreviousNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).previous;\n    }\n\n    getNextNode(node: Ast.Ast): Ast.Node | undefined {\n        return (this.map.get(node) || ({} as any)).next;\n    }\n}\n", "import type { Plugin, Printer } from \"prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parse } from \"@unified-latex/unified-latex-util-parse\";\nimport { printLatexAst } from \"./printer\";\n\nconst languages = [\n    {\n        name: \"latex\",\n        extensions: [\".tex\"],\n        parsers: [\"latex-parser\"],\n    },\n];\n\nconst parsers = {\n    \"latex-parser\": {\n        parse,\n        astFormat: \"latex-ast\",\n        locStart: (node: Ast.Node) =>\n            node.position ? node.position.start.offset : 0,\n        locEnd: (node: Ast.Node) =>\n            node.position ? node.position.end.offset : 1,\n    },\n};\n\nconst printers = {\n    \"latex-ast\": {\n        print: printLatexAst,\n    } as Printer,\n};\n\nconst prettierPluginLatex: Plugin<Ast.Node> = { languages, parsers, printers };\n\nexport { prettierPluginLatex };\n"],
  "mappings": "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",
  "names": []
}
